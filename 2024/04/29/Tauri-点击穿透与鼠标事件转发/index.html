<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Tauri 点击穿透与鼠标事件转发 - 毛呆&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="毛呆&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="毛呆&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="Tauri 点击穿透与鼠标事件转发"><meta property="og:url" content="https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/"><meta property="og:site_name" content="毛呆&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94.png"><meta property="og:image" content="https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B9%B2%E6%89%B0.gif"><meta property="og:image" content="https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/hover%E9%97%AA%E7%83%81.gif"><meta property="article:published_time" content="2024-04-29T14:12:00.000Z"><meta property="article:modified_time" content="2024-11-17T03:51:47.974Z"><meta property="article:author" content="aweikalee"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Tauri"><meta property="article:tag" content="Electron"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/"},"headline":"Tauri 点击穿透与鼠标事件转发","image":["https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94.png","https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B9%B2%E6%89%B0.gif","https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/hover%E9%97%AA%E7%83%81.gif"],"datePublished":"2024-04-29T14:12:00.000Z","dateModified":"2024-11-17T03:51:47.974Z","author":{"@type":"Person","name":"aweikalee"},"description":""}</script><link rel="canonical" href="https://blog.maodai.site/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?603c9db999df88a1cab3437e7ad365e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="毛呆&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">分类</a><a class="navbar-item" href="/categories">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-04-29T14:12:00.000Z" title="4/29/2024, 2:12:00 PM">2024-04-29</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span> / </span><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">JavaScript</a></span><span class="level-item">21 分钟读完 (大约3204个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Tauri 点击穿透与鼠标事件转发</h1><div class="content"><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于需要窗口透明的应用，通常要求透明的区域点击穿透，非透明的区域则可以使用鼠标进行交互。</p><p><strong>Tauri</strong> 和 <strong>Electron</strong> 则为开发着提供了<strong>忽略鼠标事件</strong>的方法。当鼠标消息无法发送给目标进程，那么就会得到点击穿透的效果。</p><p>但无法选择忽略的鼠标消息类型，因此开发者无法再通过鼠标事件去启停<strong>忽略鼠标消息</strong>。意味着只能启用，不能停用。无法实现更复杂的交互。</p><p>而 <strong>Electron</strong> 在此基础上增加了<strong>鼠标消息转发</strong>。拦截全局鼠标消息，然后将鼠标的移动位置转发给目标进程。开发者则可以通过鼠标移动产生的事件（<code>mousemove/mouseenter/mouseleave</code>），启停<strong>忽略鼠标消息</strong>。</p><p>本文将借鉴 <strong>Electron</strong> 中 <strong>Windows</strong> 系统的实现，并将其移植到 <strong>Tauri</strong> 中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整的代码示例：<a target="_blank" rel="noopener" href="https://github.com/aweikalee/tauri-click-through-demo">aweikalee/tauri-click-through-demo</a>。</p><p>主要参考的 <strong>Electron</strong> 代码：<a target="_blank" rel="noopener" href="https://github.com/electron/electron/blob/main/shell/browser/native_window_views_win.cc">electron/native_window_views_win.cc</a> 中的 <code>SetForwardMouseMessages</code> 方法。</p><h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>先安装依赖：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo add windows -F Win32_Foundation -F Win32_UI_WindowsAndMessaging -F Win32_Graphics_Gdi</span><br><span class="line">cargo add once_cell</span><br></pre></td></tr></tbody></table></figure><p><strong>Windows</strong> 中， 使用 <code>Win32 API</code> 管理进程，需要引入依赖 <code>windows.rs</code> 或 <code>winapi</code>。前者微软官方维护，后者社区维护。<strong>Tauri</strong> 使用 <code>windows.rs</code>，故本文也将使用 <code>windows.rs</code>。</p><p><code>once_cell</code> 等用到了再说。</p><p>接着我们需要创建一个函数代替 <strong>Tauri</strong> 原先的 <code>setIgnoreCursorEvents</code>。并暴露给前端。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将会用到的依赖，后文将不再提及</span></span><br><span class="line"><span class="keyword">use</span> once_cell::sync::Lazy;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> windows::Win32::{</span><br><span class="line">  Foundation::{HWND, LPARAM, LRESULT, RECT, WPARAM},</span><br><span class="line">  Graphics::Gdi::{PtInRect, ScreenToClient},</span><br><span class="line">  UI::WindowsAndMessaging::*,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tauri::command]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">set_ignore_cursor_events</span></span>(window: tauri::Window, ignore: <span class="built_in">bool</span>, forward: <span class="built_in">bool</span>) {</span><br><span class="line">  <span class="keyword">let</span> hwnd = {</span><br><span class="line">    <span class="keyword">let</span> hwnd = window.hwnd().unwrap(); <span class="comment">// 此处的 HWND 是 Tauri 定义的</span></span><br><span class="line">    HWND(hwnd.<span class="number">0</span>) <span class="comment">// 需要转换为 Win32 定义的 HWND</span></span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> forward = <span class="keyword">if</span> ignore { forward } <span class="keyword">else</span> { <span class="literal">false</span> };</span><br><span class="line">  <span class="keyword">unsafe</span> { set_forward_mouse_messages(hwnd, forward) }; <span class="comment">// 后续实现</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">  tauri::Builder::default()</span><br><span class="line">    .invoke_handler(tauri::generate_handler![set_ignore_cursor_events]) <span class="comment">// 暴露给前端</span></span><br><span class="line">    .run(tauri::generate_context!())</span><br><span class="line">    .expect(<span class="string">"error while running tauri application"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="忽略鼠标消息"><a href="#忽略鼠标消息" class="headerlink" title="忽略鼠标消息"></a>忽略鼠标消息</h3><p><strong>Tauri</strong> 已经实现了这一步，可以直接调用 <code>set_ignore_cursor_events</code>：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tauri::command]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">set_ignore_cursor_events</span></span>(window: tauri::Window, ignore: <span class="built_in">bool</span>, forward: <span class="built_in">bool</span>) {</span><br><span class="line">  window.set_ignore_cursor_events(ignore).unwrap();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>set_ignore_cursor_events</code> 的实现大致如下，不想了解的可以跳到下一节。</p><blockquote><p>下面的代码是 <strong>Electron</strong> 的移植版。</p></blockquote><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">set_ignore_cursor_events</span></span>(window: tauri::Window, label: &amp;<span class="built_in">str</span>, ignore: <span class="built_in">bool</span>, forward: <span class="built_in">bool</span>) {</span><br><span class="line">  <span class="keyword">let</span> hwnd = {</span><br><span class="line">    <span class="keyword">let</span> hwnd = window.hwnd().unwrap();</span><br><span class="line">    HWND(hwnd.<span class="number">0</span>)</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsafe</span> {</span><br><span class="line">    <span class="comment">// 获取窗口原有的样式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ex_style = WINDOW_EX_STYLE(GetWindowLongW(hwnd, GWL_EXSTYLE) <span class="keyword">as</span> <span class="built_in">u32</span>); <span class="comment">// 获取 hwnd 句柄的进程上的 GWL_EXSTYLE 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ignore {</span><br><span class="line">      <span class="comment">// 添加样式</span></span><br><span class="line">      ex_style |= WS_EX_TRANSPARENT | WS_EX_LAYERED;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 移除样式</span></span><br><span class="line">      ex_style &amp;= !(WS_EX_TRANSPARENT | WS_EX_LAYERED);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将样式应用到窗口上</span></span><br><span class="line">    SetWindowLongW(hwnd, GWL_EXSTYLE, ex_style.<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>添加和移除样式是通过<strong>位运算</strong>进行的，<code>WS_EX_TRANSPARENT</code> 与 <code>WS_EX_LAYERED</code> 的值分别是 <code>32</code>、<code>524288</code>。将其转换位二进制应该就很好理解了：<code>32=100000</code>、<code>524288=10000000000000000000</code>。若还不理解请补一补<strong>位运算</strong>。</p><p>通常 <code>WS_EX_TRANSPARENT</code> 或 <code>WS_EX_LAYERED</code> 都是整数常量，但在 <code>windows.rs</code> 中它们是元组：<code>WS_EX_TRANSPARENT=WINDOW_EX_STYLE(32)</code>。使用时需要频繁转换类型。当然也可以选择取出整数进行使用，比如：<code>WS_EX_TRANSPARENT.0</code> 。</p><p><code>WS_EX_TRANSPARENT</code> 样式会使<strong>鼠标事件透明</strong>（即忽略所有鼠标事件），<code>WS_EX_LAYERED</code> 样式会使窗口视觉上透明。</p><h3 id="设置鼠标消息钩子"><a href="#设置鼠标消息钩子" class="headerlink" title="设置鼠标消息钩子"></a>设置鼠标消息钩子</h3><p>当前进程无法接受任何鼠标消息，需要通过全局鼠标钩子获取鼠标位置，然后将鼠标位置转发给目标进程。</p><h4 id="声明全局变量"><a href="#声明全局变量" class="headerlink" title="声明全局变量"></a>声明全局变量</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MOUSE_HOOK_: <span class="built_in">Option</span>&lt;HHOOK&gt; = <span class="literal">None</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> FORWARDING_WINDOWS_: Lazy&lt;HashSet&lt;<span class="built_in">isize</span>&gt;&gt; = Lazy::new(|| HashSet::new());</span><br></pre></td></tr></tbody></table></figure><p>需要用到两个全局变量：</p><ul><li><code>MOUSE_HOOK_</code> 储存全局鼠标钩子的句柄，用于卸载钩子。</li><li><code>FORWARDING_WINDOWS_</code> 储存需要转发鼠标消息的进程句柄。</li></ul><p><code>FORWARDING_WINDOWS_</code> 是 <code>HashSet</code>，因大小不确定，不能直接创建为全局变量。故引入 <code>once_cell</code>，通过 <code>once_cell::Lazy</code> 进行创建。</p><h4 id="管理进程句柄"><a href="#管理进程句柄" class="headerlink" title="管理进程句柄"></a>管理进程句柄</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_forward_mouse_messages</span></span>(hwnd: HWND, forward: <span class="built_in">bool</span>) {</span><br><span class="line">  <span class="keyword">if</span> forward {</span><br><span class="line">    FORWARDING_WINDOWS_.insert(hwnd.<span class="number">0</span>); <span class="comment">// 插入</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    FORWARDING_WINDOWS_.remove(&amp;hwnd.<span class="number">0</span>); <span class="comment">// 移除</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>set_forward_mouse_messages</code> 中存在大量不安全操作，所以函数前直接添加了 <code>unsafe</code> 的声明。</p><p><strong>Electron</strong> 中 <code>FORWARDING_WINDOWS_</code> 储存的是 <code>NativeWindowViews</code> 的实例。此处实现取而代之的是直接储存进程句柄。</p><p>由于 <code>HWND</code> 并未实现 <code>Hash</code> 方法，无法确定唯一性，故直接从元组里取出原始值进行操作。</p><h5 id="修正句柄"><a href="#修正句柄" class="headerlink" title="修正句柄"></a>修正句柄</h5><p><img src="/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94.png" alt="进程结构对比"></p><p>由于 <strong>Tauri</strong> 进程内部比 <strong>Electron</strong> 多了两层进程，将消息发送给最外层的主进程，浏览器进程不会收到消息。</p><p>于是用了点脏方法，在主进程上获取第一次子进程句柄，再获取子进程句柄的第一个子进程句柄。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_forward_mouse_messages</span></span>(hwnd: HWND, forward: <span class="built_in">bool</span>) {</span><br><span class="line">  <span class="keyword">let</span> browser_hwnd = {</span><br><span class="line">    <span class="keyword">let</span> hwnd = GetWindow(hwnd, GW_CHILD);</span><br><span class="line">    GetWindow(hwnd, GW_CHILD)</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> forward {</span><br><span class="line">    FORWARDING_WINDOWS_.insert(browser_hwnd.<span class="number">0</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    FORWARDING_WINDOWS_.remove(&amp;browser_hwnd.<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>GetWindow(hwnd, GW_CHILD)</code> 获取的是第一个子进程的句柄。</p><h4 id="设置与卸载钩子"><a href="#设置与卸载钩子" class="headerlink" title="设置与卸载钩子"></a>设置与卸载钩子</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_forward_mouse_messages</span></span>(hwnd: HWND, forward: <span class="built_in">bool</span>) {</span><br><span class="line">  <span class="keyword">if</span> forward {</span><br><span class="line">    FORWARDING_WINDOWS_.insert(hwnd.<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> MOUSE_HOOK_ {</span><br><span class="line">      <span class="literal">Some</span>(_) =&gt; {}</span><br><span class="line">      <span class="literal">None</span> =&gt; {</span><br><span class="line">        MOUSE_HOOK_ =</span><br><span class="line">          <span class="literal">Some</span>(SetWindowsHookExW(WH_MOUSE_LL, <span class="literal">Some</span>(mousemove_forward), <span class="literal">None</span>, <span class="number">0</span>).unwrap());</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    FORWARDING_WINDOWS_.remove(&amp;hwnd.<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> FORWARDING_WINDOWS_.len() == <span class="number">0</span> {</span><br><span class="line">      <span class="keyword">match</span> MOUSE_HOOK_ {</span><br><span class="line">        <span class="literal">Some</span>(hook) =&gt; {</span><br><span class="line">          UnhookWindowsHookEx(hook).unwrap();</span><br><span class="line">          MOUSE_HOOK_ = <span class="literal">None</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="literal">None</span> =&gt; {}</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>全局钩子只需设置一次，卸载时则需要等所有进程都被卸载后再卸载全局钩子。</p><p><code>WH_MOUSE_LL</code> 表示低级鼠标钩子，或者说是全局鼠标钩子。<code>mousemove_forward</code> 为处理函数。因挂载的是全局钩子，故 <code>SetWindowsHookExW</code> 后两个参数用不到。</p><h5 id="SetWindowsHookExA-与-SetWindowsHookExW"><a href="#SetWindowsHookExA-与-SetWindowsHookExW" class="headerlink" title="SetWindowsHookExA 与 SetWindowsHookExW"></a><code>SetWindowsHookExA</code> 与 <code>SetWindowsHookExW</code></h5><p><code>SetWindowsHookEx</code> 存在两个版本的函数：<code>SetWindowsHookExA</code> 与 <code>SetWindowsHookExW</code>。<code>A</code> 代表 _ANSI_，<code>W</code> 代表 _UNICODE_。通常会有以下这段宏，根据编译环境，将 <code>SetWindowsHookEx</code> 定义为 <code>SetWindowsHookExA</code> 或 <code>SetWindowsHookExW</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetWindowsHookEx  SetWindowsHookExW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetWindowsHookEx  SetWindowsHookExA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></tbody></table></figure><p>由于 <strong>Tauri</strong> 中使用的都为 <em>UNICODE</em> 版本，故直接使用 <code>SetWindowsHookExW</code>。<code>Win32</code> 中很多函数都存在这样的两个版本，之后将都会使用 <em>UNICODE</em> 版本。上文出现过的 <code>GetWindowLongW</code> 和 <code>SetWindowLongW</code> 同理。</p><h3 id="处理鼠标消息"><a href="#处理鼠标消息" class="headerlink" title="处理鼠标消息"></a>处理鼠标消息</h3><p>接着实现 <code>mousemove_forward</code> 函数。将捕获到的 <code>WM_MOUSEMOVE</code> 事件，转换坐标后转发给目标进程。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"system"</span> <span class="function"><span class="keyword">fn</span> <span class="title">mousemove_forward</span></span>(</span><br><span class="line">  n_code: <span class="built_in">i32</span>,</span><br><span class="line">  w_param: WPARAM,</span><br><span class="line">  l_param: LPARAM,</span><br><span class="line">) -&gt; LRESULT {</span><br><span class="line">  <span class="keyword">if</span> n_code &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(<span class="literal">None</span>, n_code, w_param, l_param);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> w_param.<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">u32</span> == WM_MOUSEMOVE {</span><br><span class="line">    <span class="keyword">let</span> p = l_param.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> MSLLHOOKSTRUCT;</span><br><span class="line">    <span class="keyword">let</span> p = (*p).pt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;hwnd <span class="keyword">in</span> FORWARDING_WINDOWS_.iter() {</span><br><span class="line">      <span class="keyword">let</span> hwnd = HWND(hwnd);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut</span> client_rect = RECT {</span><br><span class="line">        left: <span class="number">0</span>,</span><br><span class="line">        top: <span class="number">0</span>,</span><br><span class="line">        right: <span class="number">0</span>,</span><br><span class="line">        bottom: <span class="number">0</span>,</span><br><span class="line">      };</span><br><span class="line">      GetClientRect(hwnd, &amp;<span class="keyword">mut</span> client_rect).unwrap();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut</span> p = p.clone();</span><br><span class="line">      ScreenToClient(hwnd, &amp;<span class="keyword">mut</span> p).unwrap();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> PtInRect(&amp;client_rect, p).as_bool() {</span><br><span class="line">        <span class="keyword">let</span> w = WPARAM(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> l = LPARAM(MAKELPARAM!(p.x, p.y));</span><br><span class="line">        PostMessageW(hwnd, WM_MOUSEMOVE, w, l).unwrap();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  CallNextHookEx(<span class="literal">None</span>, n_code, w_param, l_param)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>n_code</code> 为确定如何处理消息的代码。微软文档中说：_如果 nCode 小于零，则挂钩过程必须将消息传递给 CallNextHookEx 函数，而无需进一步处理，并且应返回 CallNextHookEx 返回的值_。不过我实际获取到的 <code>n_code</code> 的值只有 <code>0</code>。</li><li><code>w_param</code> 为鼠标消息标识，用于区分消息类型。我们只对 <code>WM_MOUSEMOVE</code> 消息进行处理。</li><li><code>l_param</code> 是指向 <code>MSLLHOOKSTRUCT</code> 结构体的指针的值。<code>MSLLHOOKSTRUCT</code> 上有我们需要的鼠标坐标信息。</li></ul><h4 id="获取坐标信息"><a href="#获取坐标信息" class="headerlink" title="获取坐标信息"></a>获取坐标信息</h4><p><code>l_param</code> 是个整数，内存指针的值，需要通过强转类型转为原始指针使用：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = l_param.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> MSLLHOOKSTRUCT; <span class="comment">// 强转为 MSLLHOOKSTRUCT 的原始指针</span></span><br><span class="line"><span class="keyword">let</span> p = (*p).pt; <span class="comment">// 解引用原始指针，再获取 MSLLHOOKSTRUCT 的 pt 字段</span></span><br></pre></td></tr></tbody></table></figure><h4 id="获取窗口坐标信息"><a href="#获取窗口坐标信息" class="headerlink" title="获取窗口坐标信息"></a>获取窗口坐标信息</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> client_rect = RECT {</span><br><span class="line">  left: <span class="number">0</span>,</span><br><span class="line">  top: <span class="number">0</span>,</span><br><span class="line">  right: <span class="number">0</span>,</span><br><span class="line">  bottom: <span class="number">0</span>,</span><br><span class="line">};</span><br><span class="line">GetClientRect(hwnd, &amp;<span class="keyword">mut</span> client_rect).unwrap();</span><br></pre></td></tr></tbody></table></figure><ul><li><code>GetClientRect</code> 可以获得进程窗口的位置信息。<code>left/top</code> 始终为 <code>0</code>，<code>right/bottom</code> 等同于窗口宽高。</li></ul><h4 id="转换坐标"><a href="#转换坐标" class="headerlink" title="转换坐标"></a>转换坐标</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p = p.clone();</span><br><span class="line">ScreenToClient(hwnd, &amp;<span class="keyword">mut</span> p).unwrap();</span><br></pre></td></tr></tbody></table></figure><p>先前获得到鼠标坐标是相对于屏幕的，后面需要用到相对于目标窗口的坐标，使用 <code>ScreenToClient</code> 函数进行转换。</p><h4 id="转发消息"><a href="#转发消息" class="headerlink" title="转发消息"></a>转发消息</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> PtInRect(&amp;client_rect, p).as_bool() {</span><br><span class="line">  <span class="keyword">let</span> w = WPARAM(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> l = LPARAM(MAKELPARAM!(p.x, p.y));</span><br><span class="line">  PostMessageW(hwnd, WM_MOUSEMOVE, w, l).unwrap();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>PtInRect</code> 函数用于判断坐标点是否位于预期范围内。鼠标落在窗口之外时，则不必转发消息。</li><li><code>w</code> 表示虚拟键是否已按下，如鼠标左键/右键等。</li><li><code>l</code> 为鼠标坐标。<code>l</code> 是一个32位整数，后16位储存 <code>x</code> 坐标，前16位储存 <code>y</code> 坐标。在 C++ 中可以使用 <code>MAKELPARAM</code> 宏来创建，但 Rust 中并没有这个宏，需要自行实现，如下。</li></ul><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> MAKELPARAM {</span><br><span class="line">  ($low:expr, $high:expr) =&gt; {</span><br><span class="line">    ((($low &amp; <span class="number">0xffff</span>) <span class="keyword">as</span> <span class="built_in">u32</span>) | (($high &amp; <span class="number">0xffff</span>) <span class="keyword">as</span> <span class="built_in">u32</span>) &lt;&lt; <span class="number">16</span>) <span class="keyword">as</span> _</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后使用 <code>PostMessageW</code> 将消息转发给目标进程。</p><h4 id="调用下一个钩子"><a href="#调用下一个钩子" class="headerlink" title="调用下一个钩子"></a>调用下一个钩子</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallNextHookEx(<span class="literal">None</span>, n_code, w_param, l_param)</span><br></pre></td></tr></tbody></table></figure><p>调用 <code>CallNextHookEx</code> 会调用下一个钩子，如果没有下一个钩子，则使用系统默认处理。此处若不调用（即为拦截），你的鼠标将不能工作。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>至此功能已实现，但实际跑起来还有点小问题。</p><h3 id="拖动窗口干扰"><a href="#拖动窗口干扰" class="headerlink" title="拖动窗口干扰"></a>拖动窗口干扰</h3><p><img src="/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B9%B2%E6%89%B0.gif"><br>当拖动 <strong>Webview2</strong> 创建的窗口，经过设置了转发鼠标消息的区域时，被拖动的窗口会在两个位置之间反复横跳。一个是鼠标当前位置，另一个是转发给进程的鼠标消息的坐标相对于屏幕的位置。</p><p>复现的方式：打开调试工具，拖动调试工具并经过主窗口。主窗口的位置不在屏幕 0, 0 的位置。</p><p><strong>Electron</strong> 中也存在相同的问题，只是因为一些其他机制，使得这个问题不那么明显。</p><h4 id="异步改同步"><a href="#异步改同步" class="headerlink" title="异步改同步"></a>异步改同步</h4><p>了解到 <code>PostMessage</code> 是异步的，我就尝试着将它换成了同步版的 <code>SendMessage</code>，有效地解决了问题。</p><p>使产生的干扰在在鼠标真实移动前产生，再被真实的移动覆盖，在重新渲染时使得鼠标能在正确的位置。</p><p>该方法虽然并没有解决干扰的问题，但避免了窗口反复横跳的现象。</p><h4 id="非必要不使用"><a href="#非必要不使用" class="headerlink" title="非必要不使用"></a>非必要不使用</h4><p>非必要不使用 <code>set_ignore_cursor_events</code>，在特定场景主动停用，减少副作用的影响。<strong>Electron</strong> 中有类似的实现，但并非为了解决该问题而实现的。</p><p>场景一：窗口被完全覆盖。当窗口被完全覆盖时，没有点击穿透的必要可以停用。待窗口没被完全覆盖时再恢复。</p><p>场景二：无边透明窗口，使用 <code>mousemove</code> 事件控制启停时。切换到其他窗口/失焦时，可以停用。待鼠标再次经过窗口触发 <code>mousemove</code> 事件，再选择性启用。</p><h3 id="Hover-闪烁"><a href="#Hover-闪烁" class="headerlink" title="Hover 闪烁"></a>Hover 闪烁</h3><p><img src="/2024/04/29/Tauri-%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E8%BD%AC%E5%8F%91/hover%E9%97%AA%E7%83%81.gif"><br>鼠标消息转发给 <strong>WebView</strong> 后，移到具有 Hover 样式的 DOM 上，会出现闪烁，样式在普通状态与 Hover 状态之间高频切换。每次转发消息时都会顺带产生 <code>mouseenter</code> 与 <code>mouseleave</code> 事件。</p><p><strong>Electron</strong> 中是通过 <code>SetWindowSubclass</code>（设置窗口子类），拦截 <code>WM_MOUSELEAVE</code> 事件来解决该问题。但在特定条件下还是能复现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">win.setIgnoreMouseEvents(<span class="literal">true</span>, { <span class="attr">forward</span>: <span class="literal">true</span> })</span><br><span class="line">win.loadFile(<span class="string">"app/index.html"</span>)</span><br></pre></td></tr></tbody></table></figure><p>在 <code>loadFile</code> 前调用 <code>setIgnoreMouseEvents</code>，依旧存在闪烁问题。不过一般也不会这么用，所以问题不大。</p><p>但是 <strong>Tauri</strong> 的进程结构不同，获取到的事件也不一样，根本不存在 <code>WM_MOUSELEAVE</code> 事件。没法借鉴该解决方案。</p><p>病急乱投医，我摸索出了一个看起来不那么正确的方法：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> PtInRect(&amp;client_rect, p).as_bool() {</span><br><span class="line">  <span class="keyword">let</span> w = WPARAM(<span class="number">1</span>); <span class="comment">// 由 0 改为 1 或 2 或 3</span></span><br><span class="line">  <span class="keyword">let</span> l = LPARAM(MAKELPARAM!(p.x, p.y));</span><br><span class="line">  SendMessageW(hwnd, WM_MOUSEMOVE, w, l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我也很难解释原因，虽然违背了这个参数本身的意义，但确实有效，还没有副作用。</p></body></html></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/Tauri/">Tauri</a><a class="link-muted mr-2" rel="tag" href="/tags/Electron/">Electron</a><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/14/%E6%9B%B4%E9%80%82%E5%90%88-Vue3-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%BA%93-Prorage/"><span class="level-item">更适合 Vue3 的持久化数据(localStorage)管理库 Prorage</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#代码"><span class="level-left"><span class="level-item">2</span><span class="level-item">代码</span></span></a></li><li><a class="level is-mobile" href="#移植"><span class="level-left"><span class="level-item">3</span><span class="level-item">移植</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#前期准备"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">前期准备</span></span></a></li><li><a class="level is-mobile" href="#忽略鼠标消息"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">忽略鼠标消息</span></span></a></li><li><a class="level is-mobile" href="#设置鼠标消息钩子"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">设置鼠标消息钩子</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#声明全局变量"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">声明全局变量</span></span></a></li><li><a class="level is-mobile" href="#管理进程句柄"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">管理进程句柄</span></span></a></li><li><a class="level is-mobile" href="#设置与卸载钩子"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">设置与卸载钩子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#处理鼠标消息"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">处理鼠标消息</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#获取坐标信息"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">获取坐标信息</span></span></a></li><li><a class="level is-mobile" href="#获取窗口坐标信息"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">获取窗口坐标信息</span></span></a></li><li><a class="level is-mobile" href="#转换坐标"><span class="level-left"><span class="level-item">3.4.3</span><span class="level-item">转换坐标</span></span></a></li><li><a class="level is-mobile" href="#转发消息"><span class="level-left"><span class="level-item">3.4.4</span><span class="level-item">转发消息</span></span></a></li><li><a class="level is-mobile" href="#调用下一个钩子"><span class="level-left"><span class="level-item">3.4.5</span><span class="level-item">调用下一个钩子</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#一些问题"><span class="level-left"><span class="level-item">4</span><span class="level-item">一些问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#拖动窗口干扰"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">拖动窗口干扰</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#异步改同步"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">异步改同步</span></span></a></li><li><a class="level is-mobile" href="#非必要不使用"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">非必要不使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Hover-闪烁"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Hover 闪烁</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer="defer"></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="毛呆&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 aweikalee</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/aweikalee"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer="defer"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer="defer"></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer="defer"></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer="defer"></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer="defer"></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer="defer"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer="defer"></script><script src="/js/navbar.js"></script><script src="https://cdnjs.loli.net/ajax/libs/mermaid/8.9.3/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize()</script><style>.mermaid > svg { height: auto; }</style><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script></body></html>