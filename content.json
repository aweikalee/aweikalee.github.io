{"pages":[],"posts":[{"title":"iOS Safari与PWA相关内容","text":"图标1234&lt;link rel=\"apple-touch-icon\" href=\"touch-icon-iphone.png\"&gt;&lt;link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"touch-icon-ipad.png\"&gt;&lt;link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"touch-icon-iphone-retina.png\"&gt;&lt;link rel=\"apple-touch-icon\" sizes=\"167x167\" href=\"touch-icon-ipad-retina.png\"&gt; 影响书签、阅读列表、添加到主屏（PWA）的图标 使用本地的服务器 书签和阅读列表的图标无法显示 初始屏幕（启动屏幕）1&lt;link rel=\"apple-touch-startup-image\" href=\"/launch.png\"&gt; 据说ios9后已废除，但官方至今没有作任何说明，还存在于官方文档中。 在ios12.1.4修复了。 也就是说ios9之前以及ios12.1.4之后 是可以用的。 但是限制诸多，首先必去在设置了apple-mobile-web-app-capable才有效。 其次图片需要使用合适的尺寸针对各种屏幕分辨率，基本上等同于每一种机型要设置一张图片，每张图片的尺寸不带重的。 123&lt;link rel=\"apple-touch-startup-image\" href=\"/750x1294.png\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)\" /&gt; 通过 media 对不同分辨率的屏幕进行不同的设置。 标题1&lt;meta name=\"apple-mobile-web-app-title\" content=\"AppTitle\"&gt; 添加到主屏（PWA）时的标题，如果设置了manifest.json，则会使用manifest.json里的short_name和name没有设置，并且没有manifest.json则使用head里的title标签 隐藏Safari界面1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; 仅针对添加到主屏幕（PWA）。设置之后打开主屏幕上的图标启动有别于Safari的浏览器，使其更像一个APP。并且隐藏Safari的地址栏和底部的工具栏。 在设置manifest.json后，则会使用manifest.json里的display。 \"display\": \"fullscreen\"等同于apple-mobile-web-app-capable=yes \"display\": \"standalone\"等同于apple-mobile-web-app-capable=yes \"display\": \"minimal-ui\"等同于不设置apple-mobile-web-app-capable \"display\": \"browser\"等同于不设置apple-mobile-web-app-capable 状态栏颜色1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; apple-mobile-web-app-capable开启的前提下才有效。更改顶部状态栏的颜色 black 黑色 black-translucent 原意为灰色半透明，实测为透明。（刚启动时为黑色） default 白色 除上述以外的任何值，都将设为白色 不设置apple-mobile-web-app-status-bar-style，则设为黑色 manifest.json以下属性均只在添加到主屏幕（PWA）后有效。 name 标题，优先级大于apple-mobile-web-app-title short_name 标题，优先级大于name start_url 入口地址，如要脱机访问务必指向.html文件 display 展示形式，具体参见apple-mobile-web-app-capable的说明 其他属性似乎均不支持。 其他参考资料Apple Developer 测试环境iPhone 6s iOS 12.0","link":"/2019/05/31/iOS-Safari%E4%B8%8EPWA%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"},{"title":"通过 Nginx 给静态资源加上访问密码","text":"有时候服务器上会放一些不希望公开的静态资源，那么我们可以通过 Nginx 和 htpasswd 设置访问密码。 修改 Nginx 配置文件12345server { ... auth_basic \"Please input passwod\"; # 文字提示 chrome中不会显示 auth_basic_user_file /usr/local/nginx/conf/passwd; # 认证文件} 安装 htpasswd1apt-get install apache2-utils htpasswd 是 apache2-utils 或 mini-httpd 附带的程序。所以我们安装这两者其中一个就可以获得 htpasswd 了。 创建认证文件1htpasswd -c /usr/local/src/nginx/passwd username username 是设置的用户名根据提示输入两次密码。 重启 Nginx1nginx -s reload 现在访问网站就需要用户名和密码了。","link":"/2019/08/19/%E9%80%9A%E8%BF%87-nginx-%E7%BB%99%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E4%B8%8A%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"},{"title":"如何创建有序对象？","text":"问题 在不把对象改成数组的情况下，给对象添加新的属性，怎么保证这个属性在遍历的时候是最后一个？ 解答以前 JavaScript 中对象的键名是无序的，后来在 ES2015 之后规定了键名的顺序。 键名数组分为三个部分： 可作为数组索引的键名（如 0, 1, 2），升序排列。 字符串索引，按创建顺序排列。 Symbol 索引，按创建顺序排列。 如果只使用第二类字符串索引，那么默认的顺序就满足需求了。而如果要加上第一类索引，那就需要自己维护键名的数组了，在新增和删除键名时对数组进行操作。 这个场景 Proxy 就再合适不过了。下面的例子是按键名创建顺序排序的对象，如有其他排列需求只需对 ownKeys 做文章即可。 测试用例1234567891011121314151617181920212223242526const obj = proxy({ b: 1, d: 1 })obj.c = 1obj.a = 1delete obj.dObject.defineProperties(obj, { y: { value: 1, enumerable: false, configurable: false, }, x: { value: 1, enumerable: true, configurable: false, },})obj[Symbol(2)] = 1obj[Symbol(1)] = 1console.log(Object.keys(obj))console.log(Object.getOwnPropertyNames(obj))console.log(Object.getOwnPropertySymbols(obj))// b, c, a, x// b, c, a, y, x// Symbol(2), Symbol(1) 代码12345678910111213141516171819202122232425262728293031323334353637function proxy(target) { const keys = Reflect.ownKeys(target) /* 添加 key */ function pushKey(key) { const index = keys.indexOf(key) if (!~index) keys.push(key) } /* 删除 key */ function deleteKey(key) { const index = keys.indexOf(key) if (~index) keys.splice(index, 1) } return new Proxy(target, { defineProperty(target, key, descriptor) { const result = Reflect.defineProperty(target, key, descriptor) /* 定义属性成功 则添加 key*/ if (result) pushKey(key) return result }, deleteProperty(target, key) { const result = Reflect.deleteProperty(target, key) /* 删除属性成功 则删除 key */ if (result) deleteKey(key) return result }, ownKeys() { return [].concat(keys) }, })} defineProperty: 在目标上无论新增还是修改键名/键值，都会触发。 deleteProperty: 在目标上移除键名时，会触发。 ownKeys: 获取键名列表时，返回 keys。 要点说明defineProperty / set handler.set 无法拦截 Object.defineProperty 与 Object.defineProperties。 handler.set 会拦截以代理目标为原型的对象的 set 操作。 故选择了 hanlder.defineProperty。 ownKeys该拦截器可以拦截以下操作： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() Reflect.ownKeys() 所以我们的 keys 应为上述四者的集合， Object.keys() 是 Object.OwnPropertyNames() 的子集， Reflect.ownKeys() 等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。 故在初始化时，应用 Reflect.ownKeys() 创建初始的 keys。 另外该拦截器还存在约束，使用前请务必了解一下： handler.ownKeys 的约束 | MDN。","link":"/2020/06/23/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%9C%89%E5%BA%8F%E5%AF%B9%E8%B1%A1/"},{"title":"使用 JavaScript 实现抽象相等比较（&#x3D;&#x3D;）","text":"抽象相等比较（Abstract Equality Comparison）即 == 操作符，又被称作宽松相等、非严格相等。 而在抽象相等比较的过程中，为了使 == 两侧的数据可以进行比较，会尽可能将它们转换成相同类型，这就是的隐式类型转换。 问题先来看看 == 那些令人困惑的例子： 123456789101112131415161718console.log([] == ![]) // trueconsole.log([] == []) // falseconsole.log(0 == '0') // trueconsole.log(0 == []) // trueconsole.log('0' == []) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(null == false) // falseconsole.log(undefined == false) // falseconsole.log(null == undefined) // trueconst a = { toString() { return '0' } }const b = { toString() { return '0' } }console.log(a == 0) // trueconsole.log(b == 0) // trueconsole.log(a == b) // false 让我们根据 ECMA-262 Abstract Equality Comparison 实现一个抽象相等比较吧，以此来了解比较的过程中发生了什么。 实现AbstractEqualityComparison( x, y )抽象相等比较的主体。 规范原文 If Type(x) is the same as Type(y), then ​ a. Return the result of performing Strict Equality Comparison x === y. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y. If Type(x) is BigInt and Type(y) is String, then ​ a. Let n be ! StringToBigInt(y). ​ b. If n is NaN, return false. ​ c. Return the result of the comparison x == n. If Type(x) is String and Type(y) is BigInt, return the result of the comparison y == x. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y). If Type(x) is either String, Number, BigInt, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y). If Type(x) is Object and Type(y) is either String, Number, BigInt, or Symbol, return the result of the comparison ToPrimitive(x) == y. If Type(x) is BigInt and Type(y) is Number, or if Type(x) is Number and Type(y) is BigInt, then ​ a. If x or y are any of NaN, +∞, or -∞, return false. ​ b. If the mathematical value of x is equal to the mathematical value of y, return true; otherwise return false. Return false. 注： x ==! ToNumber(x) 中的 !的意义我不清楚，但早期的规范里是没有!的，且忽略后逻辑是通顺的，后续都将按忽略处理。 译文 当 Type(x) 和 Type(y) 相同时，则 ​ a. 返回 x === y。 当 x 是 null 并且 y 是 undefined 时 true 。 当 x 是 undefined 并且 y 是 null 时 true 。 当 Type(x) 是 Number 并且 Type(y) 是 String 时，返回 x == ToNumber(y) 。 当 Type(x) 是 String 并且 Type(y) 是 Number 时，返回 ToNumber(x) == y 。 当 Type(x) 是 BigInt 并且 Type(y) 是 String 时，则 ​ a. 令 n = StringToBigInt(y) 。 ​ b. 当 n 是 NaN 时，返回 false 。 ​ c. 返回 x == n 。 当 Type(x) 是 String 并且 Type(y) 是 BigInt 时，返回 y == x 。 当 Type(x) 是 Boolean 时，返回 ToNumber(x) == y 。 当 Type(y) 是 Boolean 时，返回 x == ToNumbery) 。 当 Type(x) 是 String, Number, BigInt 或 Symbol 并且 Type(y) 是 Object 时，返回 x == ToPrimitive(y) 。 当 Type(x) 是 Object 并且 Type(y) 是 String, Number, BigInt 或 Symbol 时，返回 ToPrimitive(x) == y 。 当 Type(x) 是 BigInt 并且 Type(y) 是 Number 时，或者 当 Type(y) 是 Number 并且 Type(y) 是 BigInt 时，则 ​ a. 当 x 或 y 是 NaN, +∞, or -∞ 时，返回 false 。 ​ b. 当 x 的数值等于 y 的数值时，返回 true ，反之 false。 返回 false 。 代码最费解的想必就是 ToPrimitive 了，我们可以先不管它，先完成主体。 Type, ToNumber, ToPrimitive 等将会在后续再进行说明。 Number 和 BigInt 的数值比较，可以通过 toString(2) 将它们转成二进制字符串，再进行比较。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function AbstractEqualityComparison(x, y) { /* 1 */ if (Type(x) === Type(y)) { /* a */ return x === y } /* 2 */ if (x === null &amp;&amp; y === undefined) return true /* 3 */ if (x === undefined &amp;&amp; y === null) return true /* 4 */ if (Type(x) === 'number' &amp;&amp; Type(y) === 'string') { return AbstractEqualityComparison(x, ToNumber(y)) } /* 5 */ if (Type(x) === 'string' &amp;&amp; Type(y) === 'number') { return AbstractEqualityComparison(ToNumber(x), y) } /* 6 */ if (Type(x) === 'bigint' &amp;&amp; Type(y) === 'string') { /* a */ const n = StringToBigInt(y) /* b */ if (Number.isNaN(n)) return false /* c */ return AbstractEqualityComparison(x, n) } /* 7 */ if (Type(x) === 'string' &amp;&amp; Type(y) === 'bigint') { return AbstractEqualityComparison(y, x) } /* 8 */ if (Type(x) === 'boolean') { return AbstractEqualityComparison(ToNumber(x), y) } /* 9 */ if (Type(y) === 'boolean') { return AbstractEqualityComparison(x, ToNumber(y)) } /* 10 */ if ( ['string', 'number', 'bigint', 'symbol'].includes(Type(x)) &amp;&amp; Type(y) === 'object' ) { return AbstractEqualityComparison(x, ToPrimitive(y)) } /* 11 */ if ( Type(x) === 'object' &amp;&amp; ['string', 'number', 'bigint', 'symbol'].includes(Type(y)) ) { return AbstractEqualityComparison(ToPrimitive(x), y) } /* 12 */ if ( (Type(x) === 'bigint' &amp;&amp; Type(y) === 'number') || (Type(x) === 'number' &amp;&amp; Type(y) === 'bigint') ) { /* a */ if ([x, y].some(v =&gt; [NaN, Infinity, -Infinity].includes(v))) { return false } /* b */ return x.toString(2) === y.toString(2) } /* 13 */ return false} 注：在 12.a 中的 includes 不可使用 indexOf 代替，[NaN].indexOf(NaN) 始终返回 -1。 Type( argument )Type 的作用是获取数据的类型。 规范原文 An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, BigInt, and Object. An ECMAScript language value is a value that is characterized by an ECMAScript language type. 代码typeof 大致和 Type 一样， 但 typeof 会将 null 认为是 object，把函数认为 function， 单独对这两种类型做调整即可。 123456function Type(argument) { const type = typeof argument if (argument === null) return 'null' if (type === 'function') return 'object' return type} ToNumber( argument )ToNumber 的作用是将其他类型转换成 Number 类型。 规范原文 The abstract operation ToNumber converts argument to a value of type Number according to Table 11: Table 11: ToNumber Conversions Argument Type Result Undefined Return NaN. Null Return +0. Boolean If argument is true, return 1. If argument is false, return +0. Number Return argument (no conversion). String See grammar and conversion algorithm below. Symbol Throw a TypeError exception. BigInt Throw a TypeError exception. Object Apply the following steps:Let primValue be ? ToPrimitive(argument, hint Number).Return ? ToNumber(primValue). 译文 ToNumber 根据表 11将 argument 转换成 Number 类型的值： 表 11: ToNumber 转换 Argument 类型 结果 Undefined 返回 NaN. Null 返回 +0。 Boolean 当 argument 是 true 时，返回 1 。当 argument 是 false 时，返回 +0 。 Number 返回 argument （不进行转换）。 String 见下方语法和转换算法。 Symbol 抛出 TypeError 。 BigInt 抛出 TypeError 。 Object 应用以下步骤：1. 令 primValue = ToPrimitive(argument, hint Number)。2. 返回 ToNumber(primValue) 。 代码ToNumber与Number 几乎一致，只不过对于BigInt，ToNumber会直接抛出类型错误。 123456function ToNumber(argument) { if (Type(argument) === 'bigint') { throw new TypeError('Cannot convert bigint to number value') } return Number(argument)} StringToBigInt( argument )StringToBigInt 的作用是将 String 转成 BigInt。 代码BigInt 中 String 的解析器想必使用的就是 StringToBigInt。 在 BigInt 中当 StringToBigInt 返回值如果是 NaN 则会直接抛出错误。 借用 BigInt 实现 StringToBigInt 则就是捕获错误，返回 NaN 。 1234567891011function StringToBigInt(argument) { if (Type(argument) !== 'string') { throw new TypeError('Only accept string') } try { return BigInt(argument) } catch (e) { return NaN }} ToPrimitive( input [, PreferredType ] )ToPrimitive 的作用是将输入的值转成值类型（除了 Object 以外的基础类型）。 规范原文 Assert: input is an ECMAScript language value. If Type(input) is Object, then ​ a. If PreferredType is not present, let hint be “default”. ​ b. Else if PreferredType is hint String, let hint be “string”. ​ c. Else, ​ i. Assert: PreferredType is hint Number. ​ ii. Let hint be “number”. ​ d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive). ​ e. If exoticToPrim is not undefined, then ​ i. Let result be ? Call(exoticToPrim, input, « hint »). ​ ii. If Type(result) is not Object, return result. ​ iii. Throw a TypeError exception. ​ f. If hint is “default”, set hint to “number”. ​ g. Return ? OrdinaryToPrimitive(input, hint). Return input. 译文 断言： input 是一个 ECMAScript 语言的值. 当 Type(input) 是 Object 时，则 ​ a. 当 PreferredType 不存在时，令 hint = “default” 。 ​ b. 否则当 PreferredType 是 String 时，令 hint = “string” 。 ​ c. 否则， ​ i. 断言： PreferredType 是 Number 。 ​ ii. 令 hint = “number” 。 ​ d. 令 exoticToPrim = GetMethod(input, @@toPrimitive) 。 ​ e. 当 exoticToPrim 不是 undefined 时，则 ​ i. 令 result = Call(exoticToPrim, input, « hint ») 。 ​ ii. 当 Type(result) 不是 Object 时，返回 result 。 ​ iii. 抛出 TypeError 。 ​ f. 当 hint 是 “default” 时，令 hint = “number” 。 ​ g. 返回 OrdinaryToPrimitive(input, hint) 。 返回 input 。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function ToPrimitive(input, PreferredType) { /* 1 不需要实现 */ /* 2 */ if (Type(input) === 'object') { let hint /* a */ if (PreferredType === undefined) { hint = 'default' } /* b */ else if (PreferredType === 'string') { hint = 'string' } /* c */ else { /* i */ if (PreferredType !== 'number') { throw new TypeError('preferred type must be \"string\" or \"number\"') } /* ii */ hint = 'number' } /* d */ const exoticToPrim = GetMethod(input, Symbol.toPrimitive) /* e */ if (exoticToPrim !== undefined) { /* i */ const result = exoticToPrim.call(input, hint) /* i */ if (Type(result) !== 'object') return result /* i */ throw new TypeError('Cannot convert object to primitive value') } /* f */ if (hint === 'default') hint = 'number' /* g */ return OrdinaryToPrimitive(input, hint) } /* 3 */ return input} OrdinaryToPrimitive( o, hint )OrdinaryToPrimitive 是将 Object 转成值类型。 参数 hint 控制优先使用 toString 还是 valueOf。 规范原文 Assert: Type(O) is Object. Assert: Type(hint) is String and its value is either “string” or “number”. If hint is “string”, then ​ a. Let methodNames be « “toString”, “valueOf” ». Else, ​ a. Let methodNames be « “valueOf”, “toString” ». For each name in methodNames in List order, do ​ a. Let method be ? Get(O, name). ​ b. If IsCallable(method) is true, then ​ i. Let result be ? Call(method, O). ​ ii. If Type(result) is not Object, return result. Throw a TypeError exception. 译文 断言： Type(O) 是 Object 。 断言： Type(hint) 是 String 并且 hint 的值 是 “string” 或 “number” 。 当 hint 是 “string” 时，则 ​ a. 令 methodNames = « “toString”, “valueOf” »。 否则， ​ a. 令 methodNames = « “valueOf”, “toString” »。 遍历 methodNames ， 执行 ​ a. 令 method = Get(O, name) 。 ​ b. 当 IsCallable(method) 是 true 时，则 ​ i. 令 result = Call(method, O) 。 ​ ii. 当 Type(result) 不是 Object 时，返回 result 。 抛出 TypeError 。 代码12345678910111213141516171819202122232425262728293031323334353637383940function OrdinaryToPrimitive(o, hint) { /* 1 */ if (Type(o) !== 'object') throw new TypeError('Only accept Object') /* 2 */ if (Type(hint) !== 'string' || !['string', 'number'].includes(hint)) { throw new TypeError('Hint value must be \"string\" or \"number\"') } let methodNames /* 3 */ if (hint === 'string') { /* a */ methodNames = ['toString', 'valueOf'] } /* 4 */ else { /* a */ methodNames = ['valueOf', 'toString'] } /* 5 */ for (const name of methodNames) { /* a */ const method = Get(o, name) /* b */ if (IsCallable(method)) { /* i */ const result = method.call(o) /* ii */ if (Type(result) !== 'object') return result } } /* 6 */ throw new TypeError('Cannot convert object to primitive value')} 其他123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function GetMethod(v, p) { if (!isPropertyKey(p)) { throw new TypeError('Not valid property key') } const func = GetV(v, p) if (func === undefined || func === null) return undefined if (!IsCallable(func)) { throw new TypeError('Not callable') } return func}function isPropertyKey(argument) { if (Type(argument) === 'string') return true if (Type(argument) === 'symbol') return true return false}function Get(o, p) { if (Type(o) !== 'object') { throw new TypeError('Only accept object') } if (!isPropertyKey(p)) { throw new TypeError('Not valid property key') } return o[p]}function GetV(v, p) { if (!isPropertyKey(p)) { throw new TypeError('Not valid property key') } const o = ToObject(v) return o[p]}function IsCallable(argument) { if (Type(argument) !== 'object') return false if (!!argument.call) return true return false}function ToObject(argument) { switch (Type(argument)) { case 'boolean': return new Boolean(argument) case 'number': return new Number(argument) case 'string': return new String(argument) case 'symbol': case 'bigint': case 'object': return argument default: throw new TypeError( `Cannot convert ${Type(argument)} to object value` ) }} 测试123456789101112function test(x, y) { const a = x == y const b = AbstractEqualityComparison(x, y) const sign = a === b ? [ '%cSuccess', 'background: green; color: white;' ] : [ '%cFailure', 'background: red; color: white;' ] console.log(...sign, `[${a}]`, x, y)} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const testData1 = [ undefined, null, true, false, '123', Symbol('123'), 123, 123n, [], { valueOf() { return 123 } }, { toString() { return 123 } }]const testData2 = [ undefined, null, true, false, '123', Symbol('123'), 123, 123n, [], { valueOf() { return 123 } }, { toString() { return 123 } }]testData1.forEach((a) =&gt; { testData2.forEach((b) =&gt; { test(a, b) })}) 结语在实际开发中，是要尽可能避免使用 == 操作符，有人可能觉得这篇文章没有意义。其实我想传达的是一种学习方法，可以通过相同的方式学习 JavaScript 的其他内容。 最后，上面实现的 AbstractEqualityComparison 还是有用处的，我在上面代码的基础上写了个 抽象相等比较过程展示 ，能更清楚地看到比较的过程。不妨输入文章开头的问题，看看比较的过程吧。","link":"/2020/08/31/%E4%BD%BF%E7%94%A8-JavaScript-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%EF%BC%88-%EF%BC%89/"},{"title":"用Hexo建立Blog时所碰到的各种坑","text":"用Hexo建立Blog非常方便，并且有很多现成的主题可以选择。本文章将会记录使用过程中碰到的一些问题，以及解决方法。基础的使用方法请参考Hexo的文档或网络上其他文章。 如何优雅地插入图片本段内容建立在post_asset_folder为true的前提下进行的。开启post_asset_folder后的目录结构如下： 1234_posts├── 文章.md└── 文章 // 文件夹 └── image.jpg 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} 文章中引用图片，官方Hexo 3.0给出的方案。但是本地编写Markdown，体验会变得很糟糕。 解决方法引入hexo-asset-image。原理是遍历内容里的img标签，给src属性补上permalink。（源码不长 推荐直接阅读源码） 1![](image.jpg) 接着就可以直接使用图片名进行引用，会转化为该文章对应的文件夹中的图片。 1![](文章/image.jpg) 不过为了能让本地Markdown编写的体验，所以得在前面加上文件夹名。 但是这种方法只能改变文章内容里的图片地址，对于文件头部Front-matter的图片地址，是无能为力的。关于Front-matter的图片地址的解决方法，请参考文章封面 Thumbnail。 文章封面-Thumbnail这里采用的文章封面解决方案是基于hexo-theme-icarus主题的thumbnail。在文章头部Front-matter中设置属性thumbnail，值设为图片路径。 和正文的图片一样会遇到路径问题，并且官方的图片引用方法和hexo-asset-image都没法解决。 解决方法找到themes\\icarus\\includes\\helpers\\page.js，对get_thumbnail进行修改。 123456789101112131415161718192021222324252627282930hexo.extend.helper.register('get_thumbnail', function (post) { var config = hexo.config; var url = post.thumbnail || '' if ( url &amp;&amp; config.post_asset_folder &amp;&amp; !/http[s]*.*|\\/\\/.*/.test(url) ) { var link = post.permalink; var beginPos = getPosition(link, '/', 3) + 1; var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var linkArray = link.split('/').filter((s) =&gt; s != ''); var urlArray = url.split('/').filter((s) =&gt; s != ''); if(linkArray[linkArray.length - 1] == urlArray[0]) { urlArray.shift(); } url = '/' + link + urlArray.join('/'); } else if (!url) { var imgPattern = /\\&lt;img\\s.*?\\s?src\\s*=\\s*['|\"]?([^\\s'\"]+).*?\\&gt;/ig; var result = imgPattern.exec(post.content); if (result &amp;&amp; result.length &gt; 1) { url = result[1]; } else { url = this.url_for('images/thumbnail.svg'); } } return url}); 如果需要补充路径，则在get_thumbnail中进行补充。 文章锚点文章开启TOC，可以，通过锚点进行文章定位。但是定位时只能定位到窗口的最顶部。当我将navbar固定到顶部后，则定位的内容会被遮住。 解决方法打开themes\\icarus\\source\\js\\main.js，在底部添加代码： 12345678910window.addEventListener('hashchange', function() { var target = $(decodeURI(location.hash)); var htmlFontSize = parseInt($('html').css('font-size')) if(target.length == 1){ var top = target.offset().top - htmlFontSize * 5; if(top &gt; 0){ $('html,body').animate({ scrollTop: top }, 0); } }}); 通过监听hash变化，进行定位修正。其中htmlFontSize * 5 = navbar的高度（4rem）+ 1rem间距。 除此外还有只使用css的解决方法，以及创建隐藏的锚点进行修正。但都需要对Markdown的样式或内容进行修改。 部署缺失README.mdsource文件夹中所有.md文件将会被渲染为html。 解决方法README.md放置于source文件夹下，_config.yml中设置过滤项。 1skip_render: README.md Github Page的Custom domain被清空在Github上设置好Custom domain，在使用hexo deploy进行更新内容，会清空Custom domain。 解决方法在source文件夹中新建文件，命名为CNAME，文件的内容设为Custom domain的值。","link":"/2019/05/28/%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%E6%97%B6%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/"},{"title":"将 JSON.stringify 改造成 JS.stringify","text":"JSON.stringify 用来将 JS 变量序列化成 JSON 字符串。一般情况下普通使用是没什么问题了，但需求一旦超过了 JSON 的标准就会存在问题了。比如上篇文章中涉及到的，需要序列化任意 JS 变量用于展示。 下面将会解决 undefined, Function, NaN, Infinity, Symbol, BigInt 的序列化，以及对于循环引用的对象的处理。一步一步将 JSON.stringify 改造成 JS.stringify。推荐直接拉到底部看完整代码，看不懂再回头看思路、说明。 默认情况下 JSON.stringify 会： 忽略 undefined, Function, Symbol。 将 NaN, Infinity, -Infinity 转换成 null 遇到BigInt 会抛出错误。 现在的需求，希望它们会被处理成： undefiend: undefiend Function: &lt;Function&gt; Symbol(123): Symbol(123) NaN: NaN Infinity: Infinity -Infinity: -Infinity BigInt(123): 123n 创建一个测试用例123456789const obj = { undefined: undefined, Function: () =&gt; {}, Symbol: Symbol(123), NaN: NaN, Infinity: Infinity, '-Infinity': -Infinity, BigInt: 123n,} 简单的类型处理可能很多人不知道 JSON.stringify 还有两个可选参数，增加类型处理将会使用第二个 replacer 参数。replacer 详细信息见 JSON.stringify() - MDN。（replacer 有两种重载，后续将只考虑 replacer 为函数的情况） 接着将给 replacer 传入一个函数，来处理变量。replacer 会在进行序列化之前执行，replacer 的返回值会当作序列化的参数。 下面就直接开始实现。 串连 replacers1234567891011121314151617181920/* 待会儿要实现的 replacer */function jsReplacer(key, value) { return value}/* 串连 replacers */function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { return JSON.stringify(value, serializer(replacer, jsReplacer), space)}jsStringify(obj) 通过 serializer 将用户传入的 replacer 和 jsReplacer 进行串连。相当于 123function newReplacer(key, value) { return jsReplacer(key, replacer(key, value)) } 另外JSON.stringify 中 replacer 的 this 会指向 value 的父对象，所以这里需要通过 call 为串连的函数绑定 this。 jsReplacer1234567891011121314151617181920function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return 'undefined' case 'function': return '&lt;Function&gt;' case 'number': if (Number.isNaN(value)) return 'NaN' if (value === Infinity) return 'Infinity' if (value === -Infinity) return '-Infinity' return value case 'symbol': return value.toString() case 'bigint': return `${value}n` default: // 其他类型 不进行处理 直接进行序列化 return value }} 我们需要将不支持的类型，在 jsReplacer 中转换成可以被支持的类型，再交还给 JSON.stringify 进行序列化。一般就是处理成字符串。 合并上面的代码，运行测试用例将会得到： 123456789{ \"undefined\": \"undefined\", \"Function\": \"&lt;Function&gt;\", \"Symbol\": \"Symbol(123)\", \"NaN\": \"NaN\", \"Infinity\": \"Infinity\", \"-Infinity\": \"-Infinity\", \"BigInt\": \"123n\"} 都成功被处理了。但是都处理成字符串，那就会和字符串混淆，无法进行区分。 接着让我们去掉多余的双引号。 移除多余的双引号单单使用 replacer 中我们是无力去掉多余的双引号了，不过我们可以对序列化之后的字符串再加工。 JSON.stringify 返回给我们的是一个字符串，我们需要在这个字符串中找到我们的猎物。为了能够区分我们的猎物和普通猎物，在放生之前给我们的猎物做上标记。 标记123const SIGN = Date.now()const LEFT_MARK = `__${SIGN}`const RIGHT_MARK = `${SIGN}__` 先创建两个标记用来包裹猎物。LEFT_MARK 和 RIGHT_MARK 可以是任意字符串，你只要让它们足够特殊就可以了。这里加入了 Date.now() 做为签名。 123function mark(text) { return `${LEFT_MARK}${text}${RIGHT_MARK}`} 写一个 mark 函数，为猎物做标记，标记方式就是在左右两侧分别加上 LEFT_MARK 与 RIGHT_MARK。 12345678910111213141516171819function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return mark('undefined') case 'function': return mark('&lt;Function&gt;') case 'number': if (Number.isNaN(value)) return mark('NaN') if (value === Infinity) return mark('Infinity') if (value === -Infinity) return mark('-Infinity') return value case 'symbol': return mark(value.toString()) case 'bigint': return mark(`${value}n`) default: return value }} 在 jsReplacer 中使用 mark 对猎物进行标记。 识别用正则去匹配标记，从而获得我们的猎物： 1const REGEXP = new RegExp(`${LEFT_MARK}(.*?)${RIGHT_MARK}`, 'g') 由于我们在 jsReplacer 中处理完的字符串，交给 JSON.stringify 序列化时会多加上引号，所以我们匹配时还得加上引号。 1const REGEXP = new RegExp(`\"${LEFT_MARK}(.*?)${RIGHT_MARK}\"`, 'g') 替换123function unmark(text) { return text.replace(REGEXP, '$1')} 通过String.prototype.replace 将猎物替换成没有引号的。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const SIGN = Date.now()const LEFT_MARK = `__${SIGN}`const RIGHT_MARK = `${SIGN}__`const REGEXP = new RegExp(`\"${LEFT_MARK}(.*?)${RIGHT_MARK}\"`, 'g')function mark(text) { return `${LEFT_MARK}${text}${RIGHT_MARK}`}function unmark(text) { return text.replace(REGEXP, '$1')}function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return mark('undefined') case 'function': return mark('&lt;Function&gt;') case 'number': if (Number.isNaN(value)) return mark('NaN') if (value === Infinity) return mark('Infinity') if (value === -Infinity) return mark('-Infinity') return value case 'symbol': return mark(value.toString()) case 'bigint': return mark(`${value}n`) default: return value }}function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { const replacers = serializer(replacer, jsReplacer) const reuslt = JSON.stringify(value, replacers, space) return unmark(reuslt)} 此时运行测试用例我们将会得到： 123456789{ \"undefined\": undefined, \"Function\": &lt;Function&gt;, \"Symbol\": Symbol(123), \"NaN\": NaN, \"Infinity\": Infinity, \"-Infinity\": -Infinity, \"BigInt\": 123n} 解决对象循环引用同过上述的代码，已经能应付所有类型了，但是面对循环引用的对象，还是会抛出错误。 创建一个测试用例123456const obj = { parent: {}, child: {},}obj.child.parent = obj.parentobj.parent.child = obj.child 简化成二叉树对象也是一个树，可以用最简单的二叉树来思考。 将问题转换成算法题《验证父子不相等二叉树》。 算法题目给定一个二叉树，判断其是否是一个有效的父子不相等二叉树。 假设一个父子不相等二叉树具有如下特征： 任意节点的值不等于其任意位置的父节点的值。 当前节点的所有子节点的值，不等于当前节点的值。 上述两个特征是一个意思，不同的表达方式 示例 112345输入: 1 / \\ 2 2输出: true 示例 21234567输入: 1 / \\ 2 3&nbsp; / \\&nbsp; 1 4输出: false 题解123456789101112131415161718192021222324/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */function isValidTree(root) { const stack = [] function helper(node) { if (node === null) return true const nodeIndex = stack.indexOf(node.val) if (~nodeIndex) return false stack.push(node.val) const res = helper(node.left) &amp;&amp; helper(node.right) stack.pop() return res } return helper(root)} 一个有效树，它的左子树和右子树独立出来也会是有效树。反过来，我们需要判断一个树是否有效，需要知道它的左子树和右子树是否有效，但左子树是否有效与右子树无关，只和父树以及自身的子树有关。因此应该使用深度优先搜索的方法进行遍历。 我们要判断最底层的节点有效性，需要收集它所有的父节点。因此我们需要创建一个栈储存父节点（的值），访问时将当前节点推入栈，当前节点的子节点访问结束之后出栈。 而 JSON.stringify 的 replacer 本身就是深度优先搜索，所以直接通过 replacer 就可以解决循环引用的问题。 模拟 JSON.stringify 内部逻辑但 replacer 和上面的题解有点不同，replacer 中无法知道子节点，只能知道当前节点的父节点（通过 this）。因此我们需要对上面的算法进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function isValidTree(root) { const stack = [] let result = true function helper(node) { if (node === null) return null // this = node 的父节点 // this 是已经经过验证的父节点 或是 根节点 const thisIndex = stack.indexOf(this.val) if (~thisIndex) { // 若 stack 中已存在 this.val // 则表示此次验证的是 this 的右子树 // 那么将移除 this 之后关于左子树的信息 stack.splice(thisIndex + 1) } else { // 若 stack 中不存在 this.val // 则表示此次验证的是 this 的左子树 stack.push(this.val) } // 当前 stack 里存在的是 node 所有父节点的信息 const nodeIndex = stack.indexOf(node.val) if (~nodeIndex) { // 若 stack 中已存在 node.val // 则表示该树不是父子不相等树 result = false // 返回 null，阻止对当前节点的子节点进行搜索 return null } return node } /* 模拟 JSON.stringify 内部遍历 */ // helper 的返回值会作为下次 serch 的节点 // 无法中断操作，只能通过 helper 返回 null 来阻止子节点的搜索 function search(node) { if (node === null) return const left = helper.call(node, node.left) search(left) const right = helper.call(node, node.right) search(right) } search(root) return result} 转换成 replacer1234567891011121314151617181920212223242526272829303132function createCircularReplacer() { const stack = [] return function (key, value) { const thisIndex = stack.indexOf(this) if (~thisIndex) { stack.splice(thisIndex + 1) } else { stack.push(this) } const valueIndex = stack.indexOf(value) if (~valueIndex) return '&lt;Circular&gt;' return value }}function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { const replacers = serializer(replacer, createCircularReplacer()) const result = JSON.stringify(value, replacers, space) return result} 通过闭包将 circularReplacer 的逻辑提到了外面，createCircularReplacer 的返回值相当于之前的 helper。其他基本和上面一一对应，对照着看很容易理解了。 增加路径记录上述返回 &lt;Circular&gt; 只能知道构成了循环引用，但无法得知是从哪儿到哪儿构成循环。 只需要同 stack 相似的方式再增加一个 keys 即可。 1234567891011121314151617181920212223242526272829303132333435363738function createCircularReplacer() { const stack = [] const keys = [] function circulerText(key, value) { const valueIndex = stack.indexOf(value) // 获取与 value 相同的父节点位置 const path = keys.slice(0, valueIndex + 1) // 获取到父节点的完整路径 return `&lt;Circular ${path.join('.')}&gt;` } return function (key, value) { if (stack.length === 0) { // 当 stack 为空时，则表示当前的 value 是根节点 // 可跳过后续处理 // 并且我们并不需要根节点的父节点 stack.push(value) keys.push('~') // 用 ~ 代表根节点的 key return value } const thisIndex = stack.indexOf(this) if (~thisIndex) { stack.splice(thisIndex + 1) keys.splice(thisIndex + 1) } else { stack.push(this) } // 当 value 作为父节点时，无法得到 value 的 key // 所以要在还能知道 key 时将 key 加入到 keys 中 // 所以 keys 表示所有父节点的 key 及自身节点的 key keys.push(key) const valueIndex = stack.indexOf(value) if (~valueIndex) return circulerText(key, value) return value }} 将代码合并后运行测试用例： 123456789101112{ \"parent\": { \"child\": { \"parent\": \"&lt;Circular ~.child&gt;\" } }, \"child\": { \"parent\": { \"child\": \"&lt;Circular ~.parent&gt;\" } }} 基本符合预期了， 然后通过之前说的移除多余的双引号相同的方式进行处理， 我觉得完美了。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const SIGN = Date.now()const LEFT_MARK = `__${SIGN}`const RIGHT_MARK = `${SIGN}__`const REGEXP = new RegExp(`\"${LEFT_MARK}(.*?)${RIGHT_MARK}\"`, 'g')function mark(text) { return `${LEFT_MARK}${text}${RIGHT_MARK}`}function unmark(text) { return text.replace(REGEXP, '$1')}function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return mark('undefined') case 'function': return mark('&lt;Function&gt;') case 'number': if (Number.isNaN(value)) return mark('NaN') if (value === Infinity) return mark('Infinity') if (value === -Infinity) return mark('-Infinity') return value case 'symbol': return mark(value.toString()) case 'bigint': return mark(`${value}n`) default: return value }}function createCircularReplacer() { const stack = [] const keys = [] function circulerText(key, value) { const valueIndex = stack.indexOf(value) const path = keys.slice(0, valueIndex + 1) return mark(`&lt;Circular ${path.join('.')}&gt;`) } return function (key, value) { if (stack.length === 0) { stack.push(value) keys.push('~') return value } const thisIndex = stack.indexOf(this) if (~thisIndex) { stack.splice(thisIndex + 1) keys.splice(thisIndex + 1) } else { stack.push(this) } keys.push(key) const valueIndex = stack.indexOf(value) if (~valueIndex) return circulerText(key, value) return value }}function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { const replacers = serializer(replacer, createCircularReplacer(), jsReplacer) const reuslt = JSON.stringify(value, replacers, space) return unmark(reuslt)}","link":"/2021/03/08/%E5%B0%86-JSON-stringify-%E6%94%B9%E9%80%A0%E6%88%90-JS-stringify/"}],"tags":[{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Safari","slug":"Safari","link":"/tags/Safari/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"有问不一定答","slug":"有问不一定答","link":"/tags/%E6%9C%89%E9%97%AE%E4%B8%8D%E4%B8%80%E5%AE%9A%E7%AD%94/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"资料整理","slug":"前端/资料整理","link":"/categories/%E5%89%8D%E7%AB%AF/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Nginx","slug":"服务器/Nginx","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"},{"name":"开发记录","slug":"前端/开发记录","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]}