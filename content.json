{"pages":[],"posts":[{"title":"ES6 Proxy 诞生8年了，你有使用过吗？聊聊 Proxy 的应用场景","text":"Proxy 是 ECMAScript 6 中新增的一个 API，正式发布距今已经八年了，但你有直接使用过它吗？Proxy 有着很大潜力，但开发时却鲜有应用场景。本文将聊聊 Proxy 能怎么用，有哪些地方能用，希望能对你有所帮助。 什么是 Proxy请直接看 Proxy - JavaScript | MDN。 应用场景数据追踪数据追踪，是 Proxy 应用最多的场景，多见于状态管理库。Vue 与 Mobx 都是使用 Proxy 来对数据进行拦截，实现数据追踪，从而实现响应式数据。 Proxy 对两者来讲都是 Object.defineProperty 的代替品。Proxy 对数据的拦截更加全面、性能更好、更标准化。 相关文章很多，不过多赘述。 不可变状态React 推行的不可变状态(immutable)，是非常优秀的思想。 而 Mobx 的作者，则通过 Proxy 实现了一套不可变数据的方案 —— Immer。通过修改临时草稿来产生下一个不可变状态。相较于其他不可变库，Immer 有更低的学习成本（不需要学习更多语法和数据结构，操作普通数据一样）、更好的类型推断（没有引入新的数据结构）、更高效的性能（最小化克隆）。 关于 Immer 是如何工作的，请看官方的介绍博客 —— Introducing Immer: Immutability the easy way。 链式调用通常的链式调用，是访问的键名对应的方法，调用该方法，最后返回(新)实例。而使用 Proxy 可以使访问的键名作为参数，返回(新)代理对象。 来自 Ingvar Stepanyan 的推文： 12345678910111213const www = new Proxy(new URL(\"https://www\"), { get(target, prop) { let orig = Reflect.get(target, prop) if (typeof orig === \"function\") return orig.bind(target) if (typeof prop !== \"string\") return orig if (prop === \"then\") return Promise.prototype.then.bind(fetch(target)) target = new URL(target) target.hostname += `.${prop}` return new Proxy(target, this) },})await www.exmaple.org 非常巧妙。只可惜没有实用性以及没有其他复刻的场景。 沙箱去年微前端非常热门。iFrame 的微前端方案子应用间存在着天然的隔离，而非 iFrame 的微前端则需要自行实现沙箱（Sandbox）。 沙箱的主要作用是避免子应用污染宿主环境、避免子应用间互相影响、以及为子应用创建独立的全局环境。 以 qiankun 为例，存在两种沙箱的实现：SnapshotSandbox 与 ProxySandbox。 SnapshotSandbox，使用的还是宿主环境的 window。在挂载子应用时会对宿主 window 进行快照（浅拷贝，备份），在子应用卸载时使用快照恢复宿主的 window。而期间对 window 进行的变更则会被记录，在下次挂载时应用在当前 window 上。 ProxySandbox 则为子应用创建了 fakeWindow，用 with(fakeWindow) 包裹子应用运行。子应用访问时则优先从 fakeWindow 寻找，其次则从宿主 window 上获取。子应用进行的变更则是应用在 fakeWindow 上，并不会影响宿主 window。 SnapshotSandbox 中的 window 是单例的，意味着只能同时运行一个子应用。以及每次挂载和卸载都需要对 window 进行遍历，性能上不如 ProxySandbox。所以 ProxySandbox 的出现让 SnapshotSandbox 变得很尴尬，qiankun 还保留 SnapshotSandbox 最大的原因大概就是为了兼容低版本浏览器吧（next 分支中已移除 SnapshotSandbox）。 适配器当 iPhone 砍掉 3.5mm 耳机孔时，对于有线耳机的兼容，苹果解决方案是：3.5mm 转 Lightning 转接头。这个转接头就是一个适配器。 Proxy 本身是一个非常好的适配器，非常适合辅助封装。 localStorage 的封装localStorage 非常适合使用 Proxy 进行封装。 基础的 localStorage 封装主要是在 getItem 和 setItem 中增加了 JSON.parse 和 JSON.stringify，以便于存储对象。不用 Proxy 就能办到。 再进一步，使用 Proxy 代理 localStorage 直接通过键名访问/设置，省去调用 getItem 与 setItem。 再进一步，深度代理 localStorage，那么可以实现更深层级的对象设置。 再进一步，使其变成响应式数据，更好地与常见的视图库/框架结合。 再进一步，增加插件系统，定制化 localStorage。 写这篇文章时发现，现有的封装，基本只到了第二步与第三步。于是，我基于 @vue/reactivity 实现到了第五步 —— Prorage。 转发除了像 localStorage 大刀阔斧的改造封装，还有一种更常见的封装：对原有数据/接口进行小幅度调整。比如组件封装时的 Ref 转发。 以 Vue 为例： 12345678910111213141516171819202122const { get, has } = Reflectconst selectRef = ref() // 被封装的组件实例const _expose = new Proxy( { foo() {/* ... */} // 改写或新增的方法 }, { get(target, key) { return get(target, key) ?? get(selectRef.value || {}, key) }, // Vue 的 getExposeProxy 中取值前会先使用 has 判断是否存在 // 存在时才会从当前 expose 中取值 // 所以 has 必须写上 has(target, key) { return has(target, key) || has(selectRef.value || {}, key) } })defineExpose(_expose) 当然你也可以用原型链也是可以实现： 1234567const selectRef = ref()const _expose = { foo() {/* ... */}}watch(selectRef, (selectRef) =&gt; Object.setPrototypeOf(_expose, selectRef))defineExpose(_expose) Proxy 相较于原型链，能做更多的修正。比如 Object.keys 访问键名时，原型链的方案无法获得原型上的键名。而 Proxy 中可以通过 ownKeys 进行修正。 不过 Proxy 在控制台打印的可读性非常差，原型链可读性稍微好一些。通常开源项目这两个方案都不会使用，而是使用更为直接的方案。 惰性创建在设计模式中，单例模式下，有一个子模式叫惰性单例。就是在被调用时才创建实例，通常用于实例创建比较昂贵或是有副作用的情况，减少未使用时的性能与副作用。 大概长这样： 123456789let cache = nullfunction getInstance() { if (!cache) { cache = new Instance() } return cache}const instance = getInstance() 配上 Proxy，就可以写成这样： 1234567891011121314const { get, set } = Reflectconst obj = new Proxy({}, { get(target, key, receiver) { const cache = Reflecf.get(target, key, receiver) if (cache === undefined) { Reflect.set(target, key, new Instance(), receiver) return Reflecf.get(target, key, receiver) } return cache }})const instance = obj.instance 虽然这个示例看上没有什么意义，但实际惰性创建的使用还是很常见的。比如 Vue 的 reactive 就是在被访问时才会创建其代理对象。再比如 Prorage 也是被访问时才会解析字符串成为对象。 数据保护Proxy 可以限制读写，实现访问限制、写入校验等等。其中比较值得说的是 Readonly。 Readonly 通常是使用 Object.freeze 来实现的。Object.freeze 冻结对象是浅层的，通常需要递归遍历冻结实现深层的 Readonly。主要有三个缺点：性能消耗、对原始数据的破坏、非法赋值没有反馈。 使用 Proxy 阻止写入和删除，实现深层的 Readonly，本身是惰性创建性能上总体会比 Object.freeze 好。不会对原始数据进行修改，仅仅只是代理对象被阻止修改。在修改时还能抛出错误，给开发者反馈。 具体的实现可以参考 Vue 的 readonly。 单任务改造为多任务当前我们有一个机器，机器有一万个任务，在项目中已经设置好该机器任务的调用。现在，我们需要增加一个差不多功能的机器。 改造前： 1234567const machine = { task1() { /* ... */ }, task2() { /* ... */ }, /* 省略一万个任务 */}export default machine 使用 Proxy 改造后： 1234567891011121314151617181920const machines = [ { task1() { /* ... */ }, task2() { /* ... */ }, /* 省略一万个任务 */ }, { task1() { /* ... */ }, task2() { /* ... */ }, /* 省略一万个任务 */ }]const machine = new Proxy({}, { get(_, key) { return () =&gt; machines.forEach(machine =&gt; machine[key]?.()) }})export default machine 有序对象曾经水群时，遇到一个问题： 在不把对象改成数组的情况下，给对象添加新的属性，怎么保证这个属性在遍历的时候是最后一个？ ES2015 规定了键名的排序： 可作为数组索引的键名（如 0, 1, 2），升序排列。 字符串索引，按创建顺序排列。 Symbol 索引，按创建顺序排列。 如果键名仅包含2、3其中一种，默认排序就满足要求了。若不是，那就该 Proxy 出马了。 12345678910111213141516171819202122232425262728293031323334353637function orderedObject(target) { const keys = Reflect.ownKeys(target) /* 添加 key */ function pushKey(key) { const index = keys.indexOf(key) if (!~index) keys.push(key) } /* 删除 key */ function deleteKey(key) { const index = keys.indexOf(key) if (~index) keys.splice(index, 1) } return new Proxy(target, { defineProperty(target, key, descriptor) { const result = Reflect.defineProperty(target, key, descriptor) /* 定义属性成功 则添加 key*/ if (result) pushKey(key) return result }, deleteProperty(target, key) { const result = Reflect.deleteProperty(target, key) /* 删除属性成功 则删除 key */ if (result) deleteKey(key) return result }, ownKeys() { return [].concat(keys) }, })} 上述代码稍加调整，可以改成任何排序规则。 数组转对象有时会通过将数组转成对象或Map，通过唯一键名来访问，减少访问的时间复杂度。 1234567891011const arr = [ { name: 'menu1', label: '菜单一' }, { name: 'menu2', label: '菜单二' },]const map = arr.reduce((map, item) =&gt; { map.set(item.name, item) return map}, new Map())console.log(map.get('menu1')) // { name: 'menu1', label: '菜单一' } 但 arr 发生变更时，需要重新生成 map，或是主动维护 map。此时可以借助 Proxy 来实现自动维护。 不过由于数组的性质，实现起来会比较麻烦，需要改写所有的数组操作方法以及需要注意对 length 的处理。 代码较长： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127const arr = [ { name: \"menu1\", label: \"菜单一\" }, { name: \"menu2\", label: \"菜单二\" },]const { proxy, map } = arrayToMap(arr, (v) =&gt; v.name)proxy.push({ name: \"menu3\", label: \"菜单三\" })proxy.unshift({ name: \"menu0\", label: \"菜单零\" })proxy.splice(1, 1, { name: \"menu4\", label: \"菜单四\" })console.log(map.get(\"menu1\")) // undefinedconsole.log(map.get(\"menu4\")) // { name: 'menu4', label: '菜单四' }function arrayToMap(arr, getKey = (v) =&gt; v) { const { get, set, deleteProperty } = Reflect const map = new Map() const count = new Map() // 处理重复的元素 // 添加初始数据 arr.forEach(add) const arrayInstrumentations = createArrayInstrumentations() const proxy = new Proxy(arr, { get(target, key, receiver) { // 改写数组操作方法 if (hasOwn(arrayInstrumentations, key)) { return get(arrayInstrumentations, key, receiver) } return get(target, key, receiver) }, set(target, key, value, receiver) { if (key === \"length\") { // 直接设置 length 时，移除溢出元素 const overflow = target.slice(value) const res = set(target, key, value, receiver) if (res) overflow.forEach(remove) return res } else { // 通过下标设置，移除旧元素，添加新元素 const oldValue = get(target, key) const res = set(target, key, value, receiver) if (res) { remove(oldValue) add(value) } return res } }, deleteProperty(target, key) { const oldValue = get(target, key) const res = deleteProperty(target, key) if (res) remove(oldValue) return res }, }) function add(value) { if (isObject(value)) { const key = getKey(value) if (key === undefined) return count.set(key, (count.get(key) ?? 0) + 1) map.set(key, value) } } function remove(value) { if (isObject(value)) { const key = getKey(value) if (key === undefined) return const _count = count.get(key) ?? 0 if (_count &gt; 1) { count.set(key, _count - 1) } else { count.delete(key) map.delete(key) } } } function createArrayInstrumentations() { const instrumentations = {} ;[\"push\", \"unshift\"].forEach((key) =&gt; { instrumentations[key] = function (...args) { const res = arr[key].apply(arr, args) args.forEach(add) return res } }) ;[\"pop\", \"shift\"].forEach((key) =&gt; { instrumentations[key] = function (...args) { const res = arr[key].apply(arr, args) remove(res) return res } }) instrumentations.splice = function (start, deleteCount, ...args) { const res = arr.splice(start, deleteCount, ...args) args.forEach(add) res.forEach(remove) return res } instrumentations.reverse = function () { return arr.reverse() } return instrumentations } return { proxy, map }}function hasOwn(val, key) { return hasOwnProperty.call(val, key)}function isObject(val) { return val !== null &amp;&amp; typeof val === \"object\"} 面试题如果面试中能拿出 Proxy 解决问题，或许能让面试官眼前一亮。 惰性创建的应用朋友碰上的一道笔试题，也不知为啥笔试的时候能联系到我，让我帮帮他（好孩子不要学）。 题目如下： 给定一个由整数组成的数组 A。需要你返回一个由对象组成的数组 T，这些对象共享相同的原型，每个对象都应该有一个 value()，使下列等式成立。 T[i].value() === A[i] T[j].value() === A[j] T[i].value === T[j].value T[i].hasOwnProperty(‘value’) === false 这题实际考的是原型，正常答法就是： 12345678910111213class Node { constructor(value) { this._value = value } value() { return this._value }}function fn(A) { return A.map(value =&gt; new Node(value))} 不过我觉得初始化的性能太差了，于是我给了一份 Proxy 的解法： 12345678910111213141516171819202122class Node { constructor(value) { this._value = value } value() { return this._value }}function fn(A) { const cached = new Array(A.length) return new Proxy(A, { get(target, key, receiver) { if (target.hasOwnProperty(key) &amp;&amp; key !== 'length') { return cached[key] || (cached[key] = new Node(target[key])) } return Reflect.get(target, key, receiver) } })} a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3一道经典的面试题：当 a = ? 使以下等式成立 1(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) === true 你可以在传统解法的基础上，追加使用 Proxy 的解法： 123456789const a = new Proxy({ value: 1 }, { get(target, key, receiver) { if (key === Symbol.toPrimitive) { return () =&gt; target.value++ } return Reflect.get(target, key, receiver) }})","link":"/2023/06/25/ES6-Proxy-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"title":"NaN 不等于 NaN 引发的一场血案","text":"本文是修复第三方依赖 BUG 的记录，包含定位 BUG 的一种思路、第三方依赖的 BUG 临时解决方法、 miniprogram-computed 实现原理与源码解析。 某天，同事说使用我封装的价格组件会导致程序崩溃。 价格组件主要是对价格进行格式化与拆分，使其更符合业务与设计需求，没有复杂的逻辑。 我想着这么简单的组件，怎么会出问题呢？我之前用得都好好的。 定位整个项目中到处都有用价格组件，但只有这一处会崩溃。但一进该页面，程序就会崩溃，没法看是不是数据错了，所以通过注释大法先确认造成崩溃的代码块。 确定了是价格组件的问题后，打印了一下传入的参数，发现是个 NaN。而组件内我对 false 类型的值是做了处理的，猜测是微信小程序 properties 的类型问题或是计算属性（miniprogram-computed）的问题。 最终接着控制变量法与注释大法配合，确定了问题出在计算属性上。此时我想到了，NaN 不等于 NaN。 这就得看看 miniprogram-computed 的源码了，猜测是 NaN 不等于 NaN 引起的问题，所以可以尝试在源码里搜 ===、!==。 很幸运，直接在 behavior.ts 文件中找到了两处相关代码： 123456789101112131415161718// will be invoked when setData is calledconst updateValueAndRelatedPaths = () =&gt; { /* ... */ let needUpdate = false // check whether its dependency updated for (let i = 0; i &lt; oldPathValues.length; i++) { /* ... */ // 第一处 if (oldVal !== curVal) { needUpdate = true break } } if (!needUpdate) return false /* ... */ return true} 123456789101112131415// comparelet changed = falsefor (let i = 0; i &lt; curVal.length; i++) { const options = paths[i].options const deepCmp = options.deepCmp // 第二处 if ( deepCmp ? !deepEqual(oldVal[i], curVal[i]) : oldVal[i] !== curVal[i] ) { changed = true break }} 第一处推测是判断新旧值是否一致，不一致则会进行更新，所以碰上 NaN 时会陷入更新的死循环； 第二处由于是在根据上下文判断，是 watch 的相关方法，和我们此次的 computed 没有关系，暂时搁置。 解决根据上述推测，我们需要将 oldVal !== curVal 改为更合理的判断。写一个 equal 函数： 123456789function equal(a: unknown, b: unknown) { if (a === b) { return true } else { // 当 a 和 b 都是 NaN // NaN === NaN 是 false return a !== a &amp;&amp; b !== b }} 替换为 equal 123456789101112131415161718 // will be invoked when setData is called const updateValueAndRelatedPaths = () =&gt; { /* ... */ let needUpdate = false // check whether its dependency updated for (let i = 0; i &lt; oldPathValues.length; i++) { /* ... */- if (oldVal !== curVal) {+ if (!equal(oldVal, curVal)) { needUpdate = true break } } if (!needUpdate) return false /* ... */ return true } 好，提一个 PR 上去。好个屁！上面全是推测，都没读源码好意思提？ 临时补丁阅读源码、提交PR、合并与发版，这些时间都是不可控的。项目还等着上线，应该临时先解决问题。 我们的项目是用 npm 管理依赖的，那么可以使用 patch-package 对依赖打上临时补丁。从 node_modules 目录中找到 miniprogram-computed。 确定依赖文件首先需要确定项目的入口文件，在 package.json 中寻找（不清楚的话可以看 package.json 导入模块入口文件优先级详解）。 很容易可以得到，入口文件是 dist/index.js。 修改代码直接对 node_modules/miniprogram-computed/dist/index.js 进行修改，修改内容如同上一节说的。 碰上代码被压缩过的情况，可以借助其他代码格式化工具（比如 prettier），先进行格式化。 生成补丁执行命令： 1$ npx patch-package miniprogram-computed 会在项目根目录下生成 patches/miniprogram-computed+4.0.4.patch 文件。 最后在 package.json 中添加： 12345 { \"scripts\": {+ \"postinstall\": \"patch-package\" } } 这会使 patch-package 在安装依赖之后运行，将补丁应用到项目中。 注意事项patch-package 只会对该版本的依赖打上补丁。如果你的项目没有锁依赖版本，当依赖更新并重新安装时，补丁会无效。 源码解析虽然上面的修改，测试下来并没有什么问题，但毕竟全程是靠推测的，不放心，还是得看看源码——computed/behavior.ts。 基础原理虽然微信小程序没有 computed 的概念，但有和 watch 差不多的 observers。 computed 本身做的就是执行时收集依赖、监听依赖、将执行结果赋值，当依赖变化时重新执行、收集、监听、赋值。其中监听依赖的部分可以交给 observers 实现，剩下的就由 miniprogram-computed 实现。 基础结构对应 computed/behavior.ts L92，简化后是这样： 12345678Object.keys(computedDef).forEach((targetField) =&gt; { const updateMethod = computedDef[targetField] const val = updateMethod(this.data) this.setData({ [targetField]: val, })}) computedDef 是定义在配置项上的 computed，将 data 作为参数运行 updateMethod，将结果在设置回 data 上。 收集依赖对应 computed/behavior.ts L96 12345678910111213import * as dataTracer from './data-tracer'Object.keys(computedDef).forEach((targetField) =&gt; { const updateMethod = computedDef[targetField] const relatedPathValuesOnDef = [] // 被访问的路径 const val = updateMethod( dataTracer.create(this.data, relatedPathValuesOnDef) // 创建代理 data ) this.setData({ [targetField]: dataTracer.unwrap(val), // 解除代理，还原成原始对象。 })}) dataTracer.create 创建一个 Proxy 对象，代理 this.data。当 updateMethod 访问 Proxy 对象中的值，则会记录被访问的路径并添加到 relatedPathValuesOnDef。 生成的 val 中可能存在被 Proxy 的值，所以此处有一个 dataTracer.unwrap 将值全部还原成原始值。 至于 dataTracer 如何实现的就先不管了。 监听依赖、重新执行与赋值监听收集到的依赖路径对应的值，发生变化时重新执行 updateMethod。 对应 computed/behavior.ts L112 与 computed/behavior.ts L151。 miniprogram-computed 用 observers 监听了 data 上所有值，然后做了个脏检查，对所有计算属性的依赖值进行新旧对比。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const computedWatchInfo = this._computedWatchInfo[computedWatchDefId] // 在实例上储存相关信息Object.keys(computedDef).forEach((targetField) =&gt; { /* ... */ const pathValues = relatedPathValuesOnDef.map(({ path }) =&gt; ({ path, value: dataPath.getDataOnPath(this.data, path), })) computedWatchInfo.computedRelatedPathValues[targetField] = pathValues // 储存依赖的值 const updateValueAndRelatedPaths = () =&gt; { const oldPathValues = computedWatchInfo.computedRelatedPathValues[targetField] let needUpdate = false // 依赖新旧值对比，不同则标记为需要更新 for (let i = 0; i &lt; oldPathValues.length; i++) { const { path, value: oldVal } = oldPathValues[i] const curVal = dataPath.getDataOnPath(this.data, path) if (oldVal !== curVal) { // 此处便是本次 BUG 的发源地 needUpdate = true break } } if (!needUpdate) return false // 需要更新 则重新执行 updateMethod 重新收集依赖、储存依赖的值、赋值 // 下面这段和初始化执行的是一样的 const relatedPathValues = [] const val = updateMethod( dataTracer.create(this.data, relatedPathValues), ) this.setData({ [targetField]: dataTracer.unwrap(val), }) const pathValues = relatedPathValues.map(({ path }) =&gt; ({ path, value: dataPath.getDataOnPath(this.data, path), })) computedWatchInfo.computedRelatedPathValues[targetField] = pathValues return true } computedWatchInfo.computedUpdaters.push( updateValueAndRelatedPaths, )}) 12345678910111213141516observersItems.push({ fields: '**', // 监听 data 上所有值 observer(this: BehaviorExtend) { if (!this._computedWatchInfo) return const computedWatchInfo = this._computedWatchInfo[computedWatchDefId] if (!computedWatchInfo) return let changed: boolean do { // 运行脏检查 changed = computedWatchInfo.computedUpdaters.some((func) =&gt; func.call(this), ) } while (changed) },}) 所以当依赖的值存在 NaN 时，会一直被标记为 changed，从而导致死循环。 watch 部分前面提到 watch 的部分也存在类似的不相等比较的代码。 watch 的实现是在 observers 的基础上，增加了新旧值对比，当值一样时则不会执行。而 observers 则是只要被赋值都会执行。 虽然并不会引起死循环，但碰上 NaN 时会导致其逻辑与预期不符，所以也需要修复。 提交 PR最终提交 PR，同时修改了 computed 与 watch 两处的不相等比较。v4.3.8 及之后修复了该 BUG。","link":"/2023/05/08/NaN-%E4%B8%8D%E7%AD%89%E4%BA%8E-NaN-%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E5%9C%BA%E8%A1%80%E6%A1%88/"},{"title":"Vue2 组件二次封装 Element UI Table","text":"本文基于早先写的 《Vue3 组件二次封装 Element Plus El-Table》。再用 Vue 2 + Element UI 重新实现一遍。实现思路不变，主要针对 Vue 2 缺少的特性和坑进行处理。存在较多的奇技淫巧，实践需谨慎。 Demo：element-ui-table-proxy-demo 源码：aweikalee/element-ui-table-proxy-demo Vue 3 + Element Plus 请前往 《Vue3 组件二次封装 Element Plus El-Table》 主要思路对于 el-table 的二次封装，我希望是： 不对原有的表产生影响（过度阶段 不可能一次性改完所有表）。 尽可能保留 el-table 本身的灵活性。 增强表格功能的同时，尽可能少地动原先的代码。 对于第1点，则是保留 el-table 组件，创建新组件 MyTable，所有改动在这个新组件内部完成。 对于第2点，就是 MyTable 接受的 props(attrs) 和 slot 应与 el-table 保持一致，且应悉数传递给 el-table。 于是设计的调整方案如下： 123456789101112&lt;!-- 调整前 --&gt;&lt;el-table :data=\"data\"&gt; &lt;el-table-column prop=\"name\" label=\"名字\" /&gt; &lt;!-- 此处省略一万个 el-table-column --&gt;&lt;/el-table&gt;&lt;!-- 调整后 --&gt;&lt;MyToolbar :columns.sync=\"columns\" /&gt;&lt;MyTable :data=\"data\" :columns.sync=\"columns\"&gt; &lt;el-table-column prop=\"name\" label=\"名字\" /&gt; &lt;!-- 此处省略一万个 el-table-column --&gt;&lt;/MyTable&gt; 新封装的组件 MyTable 所做的事很简单，就是对 slot 重新排序、筛选、修改属性之后，生成一个新的 slot 再交给 el-table 处理。 MyTable 与 MyToolbar 通过父组件上 columns 同步数据。 MyTable 组件的实现基本结构template 无法满足需求，需要上 render。 另外需要将 inheritAttrs 设为 true，并主要将 $attrs 传给 el-table 组件。否则 $attrs 将会直接绑定在根 DOM 上，不会传给 el-table。 12345678910111213141516171819202122import Table from 'element-ui/lib/table'import 'element-ui/lib/theme-chalk/table.css'export default { name: 'MyTable', inheritAttrs: false, render(h) { const children = this.$slots.default // 也可以用 jsx return h( Table, { attrs: { ...this.$attrs, }, }, children ) }} 对 VNode 分类从 slot 中获取到的 VNode 除了我们要的内容外，还会有些其他东西，所以我们需要进行分类。 对于 el-table-column 的 VNode 的处理，将会以 prop 属性作为标识。没有 prop 属性的则不会作为自定义列做处理。 VNode 将会被分成3类： el-table-column 且有 prop 属性的 el-table-column 但没有 prop 属性，但 fixed=\"left\" 的 其他的 el-table-column 或不认识的 VNode 第2类，也可以并到第3类中，但我认为分成3类更符合实际需求。 Vue 3 版本封装中使用了计算属性进行实现，但 Vue 2 中 slots 并不具有响应，所以基于 slots 的操作，都需要在 render 中进行。 123456789101112131415161718192021222324252627282930313233343536373839404142import TableColumn from 'element-ui/lib/table-column'export default { render(h) { /* 对 slot 进行分类 */ const slots = { left: [], // 第1类 main: [], // 第2类 other: [], // 第3类 } this.$slots.default?.forEach((vnode) =&gt; { if (isElTableColumn(vnode)) { const { prop, fixed } = getColumnData(vnode) if (prop !== undefined) return slots.main.push(vnode) if (fixed === 'left') return slots.left.push(vnode) } slots.other.push(vnode) }) /* 分类好的 slot 按如下顺序挂载 */ const children = [slots.left, slots.main, slots.other] return /* ... */ }}/* 用于判断 vnode 是否是 el-table-column 组件 */function isElTableColumn(vnode) { return vnode?.componentOptions?.Ctor?.options?.name === TableColumn.name}/* 获取 vnode 上的属性 */function getColumnData(child: any) { const props = child.componentOptions.propsData ?? {} return { prop: props.prop, // 标识 label: props.label, // 列名称 fixed: props.fixed, // 固定位置 visiable: props.visiable ?? true, // 是否可见 }} getColumnData 中除了 visiable 外都是 el-table-column 原有的属性。 /* ... */ 代表省略的未做改动的代码 收集列数据列数据的一手来源，就是 slots.main。因此需要从 VNode 中提取出我们需要的属性和排列顺序。 12345678910111213141516171819202122232425262728293031323334353637export default { /* ... */ data() { return { columnsFromSlot: [], columnsFromStorage: [] } }, render(h) { /* ... */ const columnsFromSlot = slots.main.map((vnode) =&gt; getColumnData(vnode)) const isSame = isSameColumns(this.columnsFromSlot, columnsFromSlot) if (!isSame) { // 若列数据与原先储存的不一致，则替换，并触发更新 this.columnsFromSlot = columnsFromSlot } return /* ... */ }}/* 比较当前列数据与原先储存的列数据是否一致 */function isSameColumns(a, b) { if (a.length !== b.length) return false const keys = a[0] ? Object.keys(a[0]) : [] for (let i = 0; i &lt; a.length; i += 1) { const _a = a[i] const _b = b[i] const isSame = keys.every((key) =&gt; _a[key] === _b[key]) if (!isSame) return false } return true} columnsFromSlot 只保存最原始的列数据，我们对于列的修改，需要保存在另外的地方，后续还要做持久化储存，所以就存在了 columnsFromStorage 中。 由于 Vue 2 的 slots 没有响应，所以我们需要在 render 中收集列数据，并将列数据储存到 data 中。 render 中修改 data 的操作需要小心，任何 data 变更，都会触发 render 重新执行，处理不慎就会陷入死循环。 这里我通过 isSameColumns 来判断是否需要更新数据，有必要更新时，才进行赋值操作。整个过程就和 虚拟 DOM 似的，只不过我们这是 虚拟 DOM 上抽离出来的更精简的 虚拟 DOM。 注：当 isSameColumns 返回 true 时，更新 data，这会重新执行 render。 合并列数据现在我们有两个数据 columnsFromSlot 与 columnsFromStorage，考虑到持久化储存，储存的列的信息可能不准确（如后期新增/删除了列），取长补短，获得一个渲染时用的完整的列数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243export default { /* ... */ data() { return { columnsFromSlot: [], columnsFromStorage: [], columnsRender: [] } }, computed: { watchColumns() { return [this.columnsFromSlot, this.columnsFromStorage] }, }, watch: { // 当 columnsFromSlot 或 columnsFromStorage 有变更 // 重新生成 columns watchColumns() { const slot = [...this.columnsFromSlot] const storage = [...this.columnsFromStorage] let res = [] storage.forEach((props) =&gt; { const index = slot.findIndex(({ prop }) =&gt; prop === props.prop) if (~index) { const propsFromSlot = slot[index] res.push({ ...propsFromSlot, // 可能新增属性 所以用 slot 的数据打个底 ...props, }) slot.splice(index, 1) // storage 里不存在的列 } // slot 中没有找到的 则会被过滤掉 }) this.columnsRender = slot.concat(res) }, }, /* ... */} 生成新的 VNode前期准备都做好了，现在需要创建传给 el-table 的 slot 了。 我们需要以 columnsRender 的数据创建 refactorSlot 代替 slots.main。 123456789101112131415161718192021222324252627282930313233343536373839404142434445export default { render(h) { /* ... */ /* 对列进行筛选与排序 */ const refactorySlot = () =&gt; { const { main } = slots const columnsProp = main.map((vnode) =&gt; getColumnData(vnode).prop) /* 对 slot.main 进行改写 */ const refactorySlot = [] this.columnsRender.forEach(({ prop, visiable, fixed }) =&gt; { // 设置为不可见的 则跳过（即不渲染） if (!visiable) return // 从 slots.main 中寻找对应 prop 的 VNode let vnode = main.find((_, index) =&gt; prop === columnsProp[index]) if (!vnode) return // 克隆 VNode 准备修改部分属性 vnode = cloneVNode(vnode) // cloneVNode 的说明见下文 // componentOptions 在 cloneVNode 时是直接引用的 // 后续要修改所以主动拷贝一份 vnode.componentOptions = { ...vnode.componentOptions } vnode.componentOptions.propsData = { ...vnode.componentOptions.propsData, } const propsData = vnode.componentOptions.propsData if (fixed !== undefined) propsData.fixed = fixed refactorySlot.push(vnode) }) return refactorySlot } // 用 refactorySlot() 代替 slots.main const children = [slots.left, refactorySlot(), slots.other] return /* ... */ }} VNode 与 cloneVNodeVue 2 并没有像 Vue 3 一样直接暴露了 VNode 和 cloneVNode。所以需要些手段。 源码中存在些许 x instanof VNode 的判断，为避免副作用，所以我们要拿到原始的 VNode。可以从原型下手，获取 VNode 的构造函数（类）。 cloneVNode 直接从源码里拷一份就行，没啥副作用。 1234567891011121314151617181920212223242526272829303132333435let VNodenew Vue({ el: document.createElement('div'), render(h) { // 创建一个 vnode // 从 vnode 的原型上获取 VNode 的构造函数 // 将其存起来 const vnode = h('div') VNode = Object.getPrototypeOf(vnode).constructor this.$destroy() },})export function cloneVNode(vnode) { const cloned = new VNode( vnode.tag, vnode.data, vnode.children &amp;&amp; vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory ) cloned.ns = vnode.ns cloned.isStatic = vnode.isStatic cloned.key = vnode.key cloned.isComment = vnode.isComment cloned.fnContext = vnode.fnContext cloned.fnOptions = vnode.fnOptions cloned.fnScopeId = vnode.fnScopeId cloned.asyncMeta = vnode.asyncMeta cloned.isCloned = true return cloned} 更新列数据el-table-column 是通过 mounted 与 destroyed 两个生命周期将列数据同步给 el-table 的。但 Vue 会尽可能利用旧的实例，只会更新实例上的数据，而不是销毁重新创建。这就导致 mounted 与 destroyed 无法运行，从而会产生 el-table 中的列数据与 el-table-column 不一致。 故此处通过更新 key 来强制重新创建 el-table。 1234567891011121314151617181920212223242526272829303132export function { data() { return { key: 0, /* ... */ } }, watch: { columnsRender() { this.key += 1 }, /* ... */ }, render(h) { /* ... */ return h( Table, { attrs: { ...this.$attrs, key: this.key }, }, children ) }} 理想状态是给 children 加 key，但 Vue 2 缺少的特性与 Element UI 本身机制共同作用下，没法加到 children 上。所以退而求其次加到了 el-table 上。 追加功能接下来是追加各种功能 MyToolbar 组件的实现 Vue 2 中 $refs 并不具有响应，实现自由度远不如 Vue3 。 我选择了将数据同步至父组件的形式，关联 MyTable 与 MyToolbar。虽然这不利于后期对 MyToolbar 进行扩展，但比在 Vue 2 中使用 $refs 靠谱得多。 父组件12&lt;MyTable :columns.sync=\"columns\" /&gt;&lt;MyToolbar :columns.sync=\"columns\" /&gt; 12345export default { data() { columns: [] }} MyTable接收 columns，但不直接使用，而是在 columns 产生变更时，覆盖到 columnsFromStorage 上。 1234567891011121314151617181920212223242526272829303132export default { props: { columns: Array }, data() { return { /* ... */ columnsFromStorage: [], columnsRender: [] } }, watch: { columns(value) { if (value === this.columnsRender) return this.columnsFromStorage = value }, watchColumns() { /* ... */ this.$emit('update:columns', this.columnsRender) } }, destroyed() { /* 当前组件销毁 清空 columns */ this.$emit('update:columns', []) },} 有人就肯定会问，为什么要绕这么大圈子，直接使用 columns 代替 columnsFormStorage 不就好了吗？答：我希望 columns 不是必须设置的。 注：每次修改 columns 必须整个替换，如果想改 columns 任意值触发更新，需要给在 watch 时加上 deep: true，并且需要深度对比 columns 与 columnsRender 是否一致。 MyToolbarMyToolbar 只要使用 columns 渲染，有改动通过 $emit('update:columns', value) 进行更新即可。就不细说了。 aweikalee/element-ui-table-proxy-demo 中有简单的实现可以参考。 列数据持久化储存只要让 columnsStorage 初始化时从 localStorage 中获取，修改时写入 localStorage 即可。 1234567891011121314// 实现一个简易版本，意思一下。const storage = { set(key, value) { localStorage.setItem(key, JSON.stringify(value)) }, get(key) { try { return JSON.parse(localStorage.getItem(key)) } catch (error) { return } }} 12345678910111213141516export default { data() { return { columnsFromStorage: storage.get('columns') ?? [] } }, watch: { columns(value) { if (value === this.columnsRender) return this.columnsFromStorage = value storage.set('columns', value) }, }} 这边 stroage.get('columns') 并没有对表格进行区分储存。可以为 MyTable 增加一个属性 name，储存与读取时以 name 做为标识以区分。 当然列的设置是可以存服务器，意味着储存都是异步的，读取时请求返回之前，会进行一次渲染，请求返回后会再次渲染，这是需要特别注意的。我选择了请求完成前不渲染 children，而是使用加载的状态代替。上传则采用了防抖的方式减少与服务器交互。 KeepAlive 保留滚动条位置尽管 KeepAlive 会缓存 DOM，但 DOM 会从文档上移除。而离开文档的 DOM 是没有 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop, scrollWidth, scrollHeight, clientWidth, clientHeight 的，此时访问到的也都是 0。 在 KeepAlive 中最受影响的就是 scrollTop 和 scrollLeft，即使重新添加到文档中也无法恢复。所以我们需要在离开文档前保存它们，重新添加到文档后将保存的值再赋值到 DOM 上。 下面介绍两种方法。 方法一监听 DOM 的 scroll 事件，scroll 事件中记录当前的滚动位置。然后在 onActivated 时重新给 DOM 赋值。 直接拿 Vue 3 版本中实现的 useKeepScroll 改了改。所以看起来这个实现思路并不符合 Vue 2 常规思路。 12345678910111213141516171819export default { mounted() { /* 追加功能 */ // 记录滚动条位置 const { setElement } = useKeepScroll(this) setElement(this.$refs.table?.$refs.bodyWrapper) }, render(h) { return h( Table, { ref: 'table' /* ... */ } children ) }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function useKeepScroll(instance) { // Vue 组件实例 let scrollTop = 0 let scrollLeft = 0 let el /* 保存滚动条位置 */ function save() { if (!el) return scrollTop = el.scrollTop scrollLeft = el.scrollLeft } /* 恢复滚动条位置 */ function restore() { if (!el) return el.scrollTop = scrollTop el.scrollLeft = scrollLeft } /* 在组件恢复时 恢复滚动条位置 */ onActivated(restore) /* 添加、移除 scroll 的监听 */ let listenedEl = null function removeEventListener() { listenedEl?.removeEventListener('scroll', save) listenedEl = null } function addEventListener() { if (!el) return if (listenedEl === el) return removeEventListener() listenedEl = el listenedEl?.addEventListener('scroll', save) } instance.$on('hook:activated', addEventListener) instance.$on('hook:deactivated', removeEventListener) instance.$on('hook:activated', restore) return { setElement(value) { el = value addEventListener() } }} setElement 方法是为了万一 DOM 没有复用时，重新设置 DOM。 方法二KeepAlive 为我们提供了 deactivated ，但它定义就是 DOM 停用后的生命周期，所以 deactivated 运行的时候 DOM 已经从文档中移除了。 我们可能更需要 beforeDeactivate，但是很可惜，这个 RFC 连 Vue 3 都还没有实装。 当前的代替方案，有那么点取巧。 12345678910111213141516171819202122232425262728function useKeepScroll(instance) { let scrollTop = 0 let scrollLeft = 0 let el function save() { if (!el) return scrollTop = el.scrollTop scrollLeft = el.scrollLeft } function restore() { if (!el) return el.scrollTop = scrollTop el.scrollLeft = scrollLeft } instance.$on('hook:activated', restore) // 恢复 instance.$on('hook:deactivated', save) // 保存 return { setElement(value) { el = value addEventListener() } }} 接下来是关键了！ 12345&lt;transition&gt; &lt;keep-alive&gt; &lt;!-- 内容 略 --&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 找到使用 KeepAlive 的地方，在外面套一层 Transition 组件，此时 deactivated 就等同于 beforeDeactivate 了。 若你的项目只存在一个 KeepAlive，就非常适合用这种解决方法。 简单解释一下原理： KeepAlive 组件的 deactivate 方法中，会先将 DOM 从文档中移除，再创建微任务调用组件的 deactivated。若 VNode 上存在 transition，移除将会是变为宏任务，那么就会变成先执行微任务中的 onDeactivated 再从文档中移除了。 解决 KeepAlive 恢复时布局错位el-table 碰上 KeepAlive 时，时不时会出现表格布局错位或是固定列无法渲染的问题。 官方解决方法是，恢复时调用 doLayout。那么完全可以集成到 MyTable。 Element Plus 没有这个问题 123456789101112export function { mounted() { let firstActivated = true this.$on('hook:activated', () =&gt; { if (firstActivated) { firstActivated = false return } this.$refs.table?.doLayout() }) }} mounted 后会执行一次 activated，不必调用 doLayout。","link":"/2022/09/03/Vue2-%E7%BB%84%E4%BB%B6%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85-Element-UI-Table/"},{"title":"Vue3 组件二次封装 Element Plus Table","text":"公司里后台系统用的 Element UI，有百来个表格（el-table），历史遗留原因都是直接使用 el-table 的。突然有一天，产品说表格要可以自定义列，让用户控制列的显隐、固定和排序，最好还能持久储存。使得我不得不进行二次封装来解决，那就顺便再轻微增强一下。 Demo：element-plus-table-proxy-demo 源码：aweikalee/element-plus-table-proxy-demo Vue 2 + Element UI 请前往 《Vue2 组件二次封装 Element UI El-Table》 主要思路对于 el-table 的二次封装，我希望是： 不对原有的表产生影响（过度阶段 不可能一次性改完所有表）。 尽可能保留 el-table 本身的灵活性。 增强表格功能的同时，尽可能少地动原先的代码。 对于第1点，则是保留 el-table 组件，创建新组件 MyTable，所有改动在这个新组件内部完成。 对于第2点，就是 MyTable 接受的 props(attrs) 和 slot 应与 el-table 保持一致，且应悉数传递给 el-table。 于是设计的调整方案如下： 123456789101112&lt;!-- 调整前 --&gt;&lt;el-table :data=\"data\"&gt; &lt;el-table-column prop=\"name\" label=\"名字\" /&gt; &lt;!-- 此处省略一万个 el-table-column --&gt;&lt;/el-table&gt;&lt;!-- 调整后 --&gt;&lt;MyToolbar :table=\"table\" /&gt;&lt;MyTable :data=\"data\" :ref=\"table\"&gt; &lt;el-table-column prop=\"name\" label=\"名字\" /&gt; &lt;!-- 此处省略一万个 el-table-column --&gt;&lt;/MyTable&gt; 新封装的组件 MyTable 所做的事很简单，就是对 slot 重新排序、筛选、修改属性之后，生成一个新的 slot 再交给 el-table 处理。 MyTable 会给 MyToolbar 暴露列的数据与修改列数据的接口。（当然你也可以将 MyToolbar 封装 MyTable 内） MyTable 组件的实现基本结构首先是 template 部分（当然你可以用 render/JSX 代替），Vue 中默认会传递所有未识别的属性给最外层的标签，所以我们只需要传一个新的 slot 就可以了。 123&lt;el-table&gt; &lt;children /&gt;&lt;/el-table&gt; children 就是我们实现的新的 slot，他是 MyTable 内部创建的子组件。他和 slots.default 一样是一个函数，里面返回了 VNode。 12const slotsOrigin = useSlots()const children = () =&gt; slotsOrigin.default?.() 注：用了 setup 语法 至此，一个保留了 el-table 所有功能的二次封装，就完成了。接下来只需要再加亿点点细节完善一下。 对 VNode 分类从 slot 中获取到的 VNode 除了我们要的内容外，还会有些其他东西，所以我们需要进行分类。 对于 el-table-column 的 VNode 的处理，将会以 prop 属性作为标识。没有 prop 属性的则不会作为自定义列做处理。 VNode 将会被分成3类： el-table-column 且有 prop 属性的 el-table-column 但没有 prop 属性，但 fixed=\"left\" 的 其他的 el-table-column 或不认识的 VNode 第2类，也可以并到第3类中，但我认为分成3类更符合实际需求。 123456789101112131415161718192021222324252627282930313233343536373839const slotsOrigin = useSlots()/* 对 slot 进行分类 */const slots = computed(() =&gt; { const main = [] // 第1类 const left = [] // 第2类 const other = [] // 第3类 slotsOrigin.default?.()?.forEach((vnode) =&gt; { if (isElTableColumn(vnode)) { // 是 el-table-column 组件 const { prop, fixed } = vnode.props ?? {} // 存在 prop 属性，归第1类 if (prop !== undefined) return main.push(vnode) // 不存在 prop 属性，但 fixed=\"left\"，归第2类 if (fixed === 'left') return left.push(vnode) } // 其他，归第3类 other.push(vnode) }) return { main, left, other, }})/* 用于判断 vnode 是否是 el-table-column 组件 */function isElTableColumn(vnode) { return (vnode.type as Component)?.name === 'ElTableColumn'}/* 分类好的 slot 按如下顺序挂载 */const children = () =&gt; [slots.value.left, slots.value.main, slots.value.other] 收集列数据列数据的一手来源，就是 slots.main。因此需要从 VNode 中提取出我们需要的属性和排列顺序。 123456789101112const columns = reactive({ slot: computed(() =&gt; slots.value.main.map(({ props }) =&gt; ({ prop: props.prop, // 标识 label: props.label, // 列名称 fixed: props.fixed, // 固定位置 visiable: props.visiable ?? true // 是否可见 })), storage: [], ),}) 除了 visiable 外都是 el-table-column 原有的属性。columns.slot 只保存最原始的列数据，我们对于列的修改，需要保存在另外的地方，后续还要做持久化储存，所以就存在了 columns.storage 中。 对外提供一个修改 columns.storage 的方法。 123function updateColumns(value) { columns.storage = value} 合并列数据现在我们有两个数据 columns.slot 与 columns.storage，考虑到持久化储存，储存的列的信息可能不准确（如后期新增/删除了列），取长补短，获得一个渲染时用的完整的列数据。 12345678910111213141516171819202122232425const columns = reactive({ // 其他同上 略 render: computed(() =&gt; { const slot = [...columns.slot] const storage = [...columns.storage] const res = [] storage.forEach((props) =&gt; { const index = slot.findIndex(({ prop }) =&gt; prop === props.prop) if (~index) { const propsFromSlot = slot[index] res.push({ ...propsFromSlot, // 可能新增属性 所以用 slot 的数据打个底 ...props, }) slot.splice(index, 1) // storage 里不存在的列 } // slot 中没有找到的 则会被过滤掉 }) res.push(...slot) return res })}) 生成新的 VNode前期准备都做好了，现在需要创建传给 el-table 的 slot 了。 我们需要以 columns.render 的数据创建 refactorSlot 代替 slots.main。 123456789101112131415161718192021222324const refactorSlot = computed(() =&gt; { const { main } = slots.value const refactorySlot = [] columns.render.forEach(({ prop, visiable, fixed }) =&gt; { // 设置为不可见的 则跳过（即不渲染） if (!visiable) return // 从 slots.main 中寻找对应 prop 的 VNode const vnode = main.find((vnode) =&gt; prop === vnode.props?.prop) if (!vnode) return // 克隆 VNode 并修改部分属性 const cloned = cloneVNode(vnode, { fixed, // 这里可以根据需求 修改属性，非常灵活 }) refactorySlot.push(cloned) }) return refactorySlot}) 最后合并所有 slot ，就完成了 children 的创建 1const children = () =&gt; [slots.value.left, refactorSlot.value, slots.value.other] 更新列数据el-table-column 是通过 onMounted 与 onUnmounted 两个生命周期将列数据同步给 el-table 的。但 Vue 会尽可能利用旧的实例，只会更新实例上的数据，而不是销毁重新创建。这就导致 onMounted 与 onUmmounted 无法运行，从而会产生 el-table 中的列数据与 el-table-column 不一致。 故此处通过更新 key 来强制重新创建 el-table-column。 123&lt;el-table&gt; &lt;children :key=\"key\" /&gt;&lt;/el-table&gt; 12const key = ref(0)watch(refactorSlot, () =&gt; (key.value += 1)) 暴露接口123&lt;el-table ref=\"table\"&gt; &lt;children :key=\"key\" /&gt;&lt;/el-table&gt; 12345678910111213const table = ref()defineExpose({ // 提供访问 el-table 途径 table, // 列的数据 columns: computed(() =&gt; readonly(columns.render)), // 修改列的数据（要求全覆盖） updateColumns(value) { columns.storage = value }}) 至此，我们主体结构就搭完了，完整代码可以到 aweikalee/element-plus-table-proxy-demo 查看。 追加功能接下来就是追加各种功能。 MyToolbar 组件的实现MyTable 对外提供了 columns 与 updateColumns，通过它们我们可以根据需求实现一个自定义列的显示、固定和排序。由于这边怎么实现都行，就不细说了。aweikalee/element-plus-table-proxy-demo 中有简单的实现可以参考。 列数据持久化储存只要让 columns.storage 初始化时从 localStorage 中获取，修改时写入 localStorage 即可。 1234567891011121314// 实现一个简易版本，意思一下。const storage = { set(key, value) { localStorage.setItem(key, JSON.stringify(value)) }, get(key) { try { return JSON.parse(localStorage.getItem(key)) } catch (error) { return } }} 1234567891011121314151617const columnsFormStorage = ref( storage.get('columns') ?? [])const columns = reactive({ // 其他不变 略 storage: computed({ get() { return columnsFormStorage.value }, set(value) { columnsFormStorage.value = value storage.set('columns', value) } })}) 这边 stroage.get('columns') 并没有对表格进行区分储存。可以为 MyTable 增加一个属性 name，储存与读取时以 name 做为标识以区分。 当然列的设置是可以存服务器，意味着储存都是异步的，读取时请求返回之前，会进行一次渲染，请求返回后会再次渲染，这是需要特别注意的。我选择了请求完成前不渲染 children，而是使用加载的状态代替。上传则采用了防抖的方式减少与服务器交互。 KeepAlive 保留滚动条位置尽管 KeepAlive 会缓存 DOM，但 DOM 会从文档上移除。而离开文档的 DOM 是没有 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop, scrollWidth, scrollHeight, clientWidth, clientHeight 的，此时访问到的也都是 0。 在 KeepAlive 中最受影响的就是 scrollTop 和 scrollLeft，即使重新添加到文档中也无法恢复。所以我们需要在离开文档前保存它们，重新添加到文档后将保存的值再赋值到 DOM 上。 下面介绍两种方法。 方法一监听 DOM 的 scroll 事件，scroll 事件中记录当前的滚动位置。然后在 onActivated 时重新给 DOM 赋值。 1&lt;el-table ref=\"table\"&gt;&lt;/el-table&gt; 123456const table = ref()const scrollRef = computed(() =&gt; { // el-table 中滚动的容器 return table.value?.$refs.bodyWrapper})useKeepScroll(scrollRef) 123456789101112131415161718192021222324252627282930313233343536373839404142function useKeepScroll(el) { // 这是一个 ref 对象 let scrollTop = 0 let scrollLeft = 0 /* 保存滚动条位置 */ function save() { if (!el.value) return scrollTop = el.value.scrollTop scrollLeft = el.value.scrollLeft } /* 恢复滚动条位置 */ function restore() { if (!el.value) return el.value.scrollTop = scrollTop el.value.scrollLeft = scrollLeft } /* 在组件恢复时 恢复滚动条位置 */ onActivated(restore) /* 添加、移除 scroll 的监听 */ let listenedEl = null function removeEventListener() { listenedEl?.removeEventListener('scroll', save) listenedEl = null } function addEventListener() { if (!el.value) return if (listenedEl === el.value) return removeEventListener() listenedEl = el.value listenedEl?.addEventListener('scroll', save) } watch(el, addEventListener) onActivated(addEventListener) onDeactivated(removeEventListener)} 方法二KeepAlive 为我们提供了 onDeactivated ，但它定义就是 DOM 停用后的生命周期，所以 onDeactivated 运行的时候 DOM 已经从文档中移除了。 我们可能更需要 onBeforeDeactivate，但是很可惜，该 RFC 还没有实装。 当前的代替方案，有那么点取巧。 1234567891011121314151617181920function useKeepScroll(el) { let scrollTop = 0 let scrollLeft = 0 function save() { if (!el.value) return scrollTop = el.value.scrollTop scrollLeft = el.value.scrollLeft } function restore() { if (!el.value) return el.value.scrollTop = scrollTop el.value.scrollLeft = scrollLeft } onActivated(restore) // 恢复 onDeactivated(save) // 保存} 接下来是关键了！ 12345&lt;Transition&gt; &lt;KeepAlive&gt; &lt;!-- 内容 略 --&gt; &lt;/KeepAlive&gt;&lt;/Transition&gt; 找到使用 KeepAlive 的地方，在外面套一层 Transition 组件，此时 onDeactivated 就等同于 onBeforeDeactivate 了。 若你的项目只存在一个 KeepAlive，就非常适合用这种解决方法。 简单解释一下原理： KeepAlive 组件的 deactivate 方法中，会先将 DOM 从文档中移除，再创建微任务调用组件的 onDeactivated。若 VNode 上存在 transition，移除将会是变为宏任务，那么就会变成先执行微任务中的 onDeactivated 再从文档中移除了。","link":"/2021/12/20/Vue3-%E7%BB%84%E4%BB%B6%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85-Element-Plus-Table/"},{"title":"iOS Safari与PWA相关内容","text":"图标1234&lt;link rel=\"apple-touch-icon\" href=\"touch-icon-iphone.png\"&gt;&lt;link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"touch-icon-ipad.png\"&gt;&lt;link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"touch-icon-iphone-retina.png\"&gt;&lt;link rel=\"apple-touch-icon\" sizes=\"167x167\" href=\"touch-icon-ipad-retina.png\"&gt; 影响书签、阅读列表、添加到主屏（PWA）的图标 使用本地的服务器 书签和阅读列表的图标无法显示 初始屏幕（启动屏幕）1&lt;link rel=\"apple-touch-startup-image\" href=\"/launch.png\"&gt; 据说ios9后已废除，但官方至今没有作任何说明，还存在于官方文档中。 在ios12.1.4修复了。 也就是说ios9之前以及ios12.1.4之后 是可以用的。 但是限制诸多，首先必去在设置了apple-mobile-web-app-capable才有效。 其次图片需要使用合适的尺寸针对各种屏幕分辨率，基本上等同于每一种机型要设置一张图片，每张图片的尺寸不带重的。 123&lt;link rel=\"apple-touch-startup-image\" href=\"/750x1294.png\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)\" /&gt; 通过 media 对不同分辨率的屏幕进行不同的设置。 标题1&lt;meta name=\"apple-mobile-web-app-title\" content=\"AppTitle\"&gt; 添加到主屏（PWA）时的标题，如果设置了manifest.json，则会使用manifest.json里的short_name和name没有设置，并且没有manifest.json则使用head里的title标签 隐藏Safari界面1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; 仅针对添加到主屏幕（PWA）。设置之后打开主屏幕上的图标启动有别于Safari的浏览器，使其更像一个APP。并且隐藏Safari的地址栏和底部的工具栏。 在设置manifest.json后，则会使用manifest.json里的display。 \"display\": \"fullscreen\"等同于apple-mobile-web-app-capable=yes \"display\": \"standalone\"等同于apple-mobile-web-app-capable=yes \"display\": \"minimal-ui\"等同于不设置apple-mobile-web-app-capable \"display\": \"browser\"等同于不设置apple-mobile-web-app-capable 状态栏颜色1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; apple-mobile-web-app-capable开启的前提下才有效。更改顶部状态栏的颜色 black 黑色 black-translucent 原意为灰色半透明，实测为透明。（刚启动时为黑色） default 白色 除上述以外的任何值，都将设为白色 不设置apple-mobile-web-app-status-bar-style，则设为黑色 manifest.json以下属性均只在添加到主屏幕（PWA）后有效。 name 标题，优先级大于apple-mobile-web-app-title short_name 标题，优先级大于name start_url 入口地址，如要脱机访问务必指向.html文件 display 展示形式，具体参见apple-mobile-web-app-capable的说明 其他属性似乎均不支持。 其他参考资料Apple Developer 测试环境iPhone 6s iOS 12.0","link":"/2019/05/31/iOS-Safari%E4%B8%8EPWA%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"},{"title":"package.json 导入模块入口文件优先级详解 main, browser, module, exports","text":"模块入口文件在 package.json 中进行描述，通常使用 main, browser, module, exports 等字段。本文将对各字段的意义与诞生原因、优先级进行说明。并以 Node、Webpack、Vite 为例，对比模块入口处理上的差异。 字段说明mainmain 是最为基础且古老的入口字段，由 Node 与 npm 定义。当 main 字段都不存在时，通常会使用 index.js 作为入口。 main | package.json | npm Docs main | Modules: Packages | Node.js Documentation 使用方法123{ \"main\": \"./index.js\"} modulemodule 字段提供符合 ESM 规范的模块入口。 2015年 ESM 规范诞生，使用 CommonJS 的模块规范 Node 开始向 ESM 规范过渡，社区出现了 module 字段的提案：A Proposal for Node.js Modules。 但 Node 却并未采纳，而是使用了 { \"type\": \"module\" } 代替。 不过，打包工具普遍支持了该字段。只是实现的与提案有很大差距，实际情况是，module 和 main 一样对待，只是优先级更高。 使用方法123{ \"module\": \"./index.esm.js\"} browserbrowser 字段提供对浏览器环境更友好的模块入口。 来自于提案：package-browser-field-spec。社区普遍认可、并实现该方案，然后在2018年才被 npm 吸收到文档（npm 除了文档中提到一句话以外，似乎并没有做任何工作）。 browser | package.json | npm Docs 使用方法123{ \"browser\": \"./index.browser.js\"} browser(字符串) 将代替 main, module。 另一种对象的写法，键名(Key)匹配被访问的路径，键值(Value)则是实际路径： 12345678{ \"main\": \"./index.js\", \"module\": \"./index.mjs\", \"browser\": { \"./index.js\": \"./index.browser.js\", \"./index.mjs\": \"./index.browser.esm.js\" }} browser(对象) 不仅可以作为入口文件的别名，也可以用于包内部依赖的别名，比如： 12345678{ \"main\": \"./index.js\", \"browser\": { \"axios\": \"./axios.js\", \"./dom.js\": \"./dom.browser.js\", \"log\": false }} 当 ./index.js 文件使用到这三个依赖时： axios 模块解析到本地文件 ./axios.js。 ./dom.js 本地文件解析到另一个本地文件 ./dom.browser.js。 禁用 log 模块。 exports2018年，Node 社区出现了一个更为现代的提案：proposal-pkg-exports，在 Node v12.7.0 版本实现。 exports 字段允许通过访问路径、运行环境(node/browser 等)、模块类型(require/import/types/css 等)组合确定最终的入口文件。 运行环境与模块类型的支持，Node 及打包工具之间的实现均有差异。 exports 是对外提供多个入口，还有另一个字段 imports 是对内修改依赖（有点像 browser）。 使用方法说来话长，建议直接看 Module Packages | Node.js Documentation 或 Package exports | Webpack。 优先级 默认版虽然前端打包工具基本是运行在 Node 中的，但打包文件时模块的处理基本是由打包工具自己封装的 Resolver 处理的，存在一些差异，以下以 Node, Webpack, Vite 三者为例说明模块入口优先级的处理。 打包工具提供了些模块入口的配置，实际逻辑相对繁琐，不过大多数情况下我们使用的都是默认配置，所以先讲默认配置下的优先级，下一节再讲原始逻辑。 Node 环境 exports main Node 不支持其他字段，所以非常简单。打包工具则是基于 Node 的标准进行扩展的。 Webpack browser(对象) exports browser(字符串) module main 若构建目标不是 Web，则跳过 browser 字段。 Webpack 会尽可能尝试去获得一个可以用的文件。 Vite browser(对象) exports browser(字符串)，当 browser 获得的文件不是 ESM 模块时，module 优先级会提升到 browser 之前。 module main 若构建目标不是 Web，则跳过 browser 字段。 Vite 会按优先级获得路径后，再尝试获得文件，若获得不到则抛出错误。 优先级 原始逻辑版WebpackWebpack 相关的配置主要在 resolve 中，主要影响优先级的有 exportsFields, mainFields, aliasFields，这些参数将会传给 enhanced-resolve 处理。 exportsFields：定义多个和 exports 相同作用的字段。 mainFields：定义多个和 main, browser(字符串), module 相同作用的字段。 aliasFields：定义多个别名对象的字段，如 browser(对象)。 若用户没有设置，Webpack 会为他们设置默认值： exportsFields：['exports']。 mainFields：当 target 为 webworker, web 或没有设置时默认值为 ['browser', 'module', 'main']，否则为 ['module', 'main']。 aliasFields：['browser']。 enhanced-resolve 中主要由 ExportsFieldPlugin, MainFieldPlugin, AliasFiledPlugin 接受参数进行处理。 大致的流程图如下： flowchart TD input[/输入 模块名/] output[/输出 模块实际路径/] subgraph Resolver ExportsFieldPlugin MainFieldPlugin AliasFiledPlugin end input --&gt; Resolver --&gt; output subgraph ExportsFieldPlugin matchExports{是否有符合当前环境的入口} hasNextExports{还有 ExportsFields 吗?} nextExportsField[(下一个 ExportsField)] exportGoToMain[(运行 MainFieldPlugin)] matchExports -- 没有 --&gt; hasNextExports hasNextExports -- 没了 --&gt; exportGoToMain hasNextExports -- 还有 --&gt; nextExportsField nextExportsField --&gt; matchExports end subgraph MainFieldPlugin getMainField[/获得字段对应的值/] isString{是否为字符串?} hasNextMain{还有 MainFields 吗?} nextMainField[(下一个 MainField)] throwError[/抛出错误/] getMainField --&gt; isString isString --&gt; 否 --&gt; hasNextMain hasNextMain -- 没了 --&gt; throwError hasNextMain -- 还有 --&gt; nextMainField nextMainField --&gt; getMainField end subgraph AliasFiledPlugin aliasInput[/输入/] AliasFileds[AliasFileds 对应的字段若是对象则转换为别名] hasAlias{是否存在别名?} tryAliasFile{别名路径文件是否存在?} tryFile{原路径文件是否存在?} aliasOutput[/输出路径/] aliasInput -- 匹配别名 --&gt; AliasFileds --&gt; hasAlias hasAlias -- 存在 --&gt; tryAliasFile hasAlias -- 不存在 --&gt; tryFile tryAliasFile -- 不存在 --&gt; tryFile tryAliasFile -- 存在 --&gt; aliasOutput tryFile -- 存在 --&gt; aliasOutput end tryFile -- 不存在 --&gt; ExportsFieldPlugin exportGoToMain --&gt; MainFieldPlugin matchExports -- 有 --&gt; aliasInput isString -- 是 --&gt; aliasInput ViteVite 的配置也主要在 resolve 中，有 mainFields, browserField。参数会传给 resolvePlugin 处理。 mainFields：定义多个和 main, module 相同作用的字段。 browserField，已废弃。 若用户没有设置，Vite 会设置默认值为： mainFields：['module', 'jsnext:main', 'jsnext']。 browserField：true。 jsnext:main 与 jsnext 和 module 是一样的作用，当时认为 module 会被标准化，所以 jsnext 被废弃了。pkg.module | rollup。 相关逻辑基本在 resolvePackageEntrys 中，以下流程图将这段代码分成了6块，并删掉了一些边缘逻辑。 flowchart TD input[/输入 模块名/] output[/输出 模块实际路径/] subgraph resolvePlugin exports --&gt; browserString --&gt; mainFields --&gt; main --&gt; entryPoints --&gt; browserObject end input --&gt; resolvePlugin --&gt; output subgraph exports exportsOuput[/输出/] matchExports{是否有 exrpots\\n且有符合当前环境的入口?} matchExports -- 有 --&gt; a1[符合的路径] --&gt; exportsOuput matchExports -- 没有 --&gt; a2[空值] --&gt; exportsOuput end subgraph browserString[\"browser(字符串)\"] browserStringInput[/输入/] browserStringOuput[/输出/] targetWeb{\"构建目标是否为 Web?\\n!ssr || ssrTarget === 'webworker'\"} browserStringInputIsNull{输入的值是否为空\\n或是否以 .mjs 结尾?} browserIsString{broswer 是字符串吗?} hasModule{mainFields 中\\n是否有 module\\n且 module 的值是否为字符串?} tryBrowserString{browser 指向的文件是 ESM 模块吗?} useBrowserInput[输入的值] useBrowserString[browser 的值] useModule[module 的值] browserStringInput --&gt; targetWeb targetWeb -- 是 --&gt; browserStringInputIsNull targetWeb -- 不是 --&gt; useBrowserInput --&gt; browserStringOuput browserStringInputIsNull -- 是 --&gt; browserIsString browserStringInputIsNull -- 不是 --&gt; useBrowserInput browserIsString -- 是 --&gt; hasModule browserIsString -- 不是 --&gt; useBrowserInput hasModule -- 有 --&gt; tryBrowserString hasModule -- 没有 --&gt; useBrowserString --&gt; browserStringOuput tryBrowserString -- 是 --&gt; useBrowserString tryBrowserString -- 不是 --&gt; useModule --&gt; browserStringOuput end subgraph mainFields mainFieldsInput[/输入/] mainFieldsOuput[/输出/] mainFieldsInputFromExports{输入的值是否来源于 exports?} mainFieldsInputIsNull{输入的值是否为空n或是否以 .mjs 结尾?} getField[从 mainFields 中\\n获取一个字段及对应的值] fieldIsString{字段不为 browser\\n且值是字符串吗?} nextMainFields{mainFields中\\n是否还有字段?} useMainFiledsInput[输入的值] useMainFields[该字段的值] mainFieldsInput --&gt; mainFieldsInputFromExports mainFieldsInputFromExports -- 不是 --&gt; mainFieldsInputIsNull mainFieldsInputFromExports -- 是 --&gt; useMainFiledsInput mainFieldsInputIsNull -- 是 --&gt; getField mainFieldsInputIsNull -- 不是 --&gt; useMainFiledsInput --&gt; mainFieldsOuput getField --&gt; fieldIsString fieldIsString -- 是 --&gt; useMainFields --&gt; mainFieldsOuput fieldIsString -- 不是 --&gt; nextMainFields nextMainFields -- 有 --&gt; getField nextMainFields -- 没有 --&gt; useMainFiledsInput end subgraph main mainInput[/输入/] mainOuput[/输出/] mainInputIsNull{输入的值是否为空?} mainInput --&gt; mainInputIsNull mainInputIsNull -- 是 --&gt; useMain[main 的值] --&gt; mainOuput mainInputIsNull -- 不是 --&gt; 输入的值 --&gt; mainOuput end subgraph entryPoints entryPointsInput[/输入/] entryPointsOuput[/输出/] entryPointsInputIsNull{输入的值是否为空?} entryPointsInput --&gt; entryPointsInputIsNull entryPointsInputIsNull -- 是 --&gt; f1[\"['index.js', 'index.json', 'index.node']\"] --&gt; entryPointsOuput entryPointsInputIsNull -- 不是 --&gt; f2[\"[输入的值]\"] --&gt; entryPointsOuput end subgraph browserObject[\"browser(对象)\"] browserObjectInput[/\"输入(entryPoints)\"/] browserObjectOuput[/输出/] getEntry[从 entryPoints 中\\n获取一个值] targetWebObject{\"构建目标是否为 Web?\"} browserIsObject{browser 是对象吗?} matchBrowserObject{是否有匹配的别名?} tryFsResolve{指向的文件是否存在?} nextEntry[entryPoints中\\n是否还有值?] useBrowserObjectInput[输入的值] useBrowserObject[匹配的别名路径] browserObjectInput --&gt; getEntry --&gt; targetWebObject targetWebObject -- 是 --&gt; browserIsObject targetWebObject -- 不是 --&gt; useBrowserObjectInput --&gt; tryFsResolve browserIsObject -- 是 --&gt; matchBrowserObject browserIsObject -- 不是 --&gt; useBrowserObjectInput matchBrowserObject -- 有 --&gt; useBrowserObject --&gt; tryFsResolve matchBrowserObject -- 没有 --&gt; useBrowserObjectInput tryFsResolve -- 存在 --&gt; browserObjectOuput tryFsResolve -- 不存在 --&gt; nextEntry nextEntry -- 有 --&gt; getEntry nextEntry -- 没有 --&gt; g1[空值] --&gt; browserObjectOuput end 最终输出的路径获取不到文件时，会抛出错误。 Vite 对于 browser 字段是单独处理的。 Vite 认为 .mjs 文件不是最优的选择，降低了他的优先级 fix: lower .mjs resolve priority，但我并不明白原因。 虽然 browserField 废弃了，但若传值为 false，则基本等同于构建目标不为 Web，跳过部分逻辑。 其他参考 main-fields | esbuild - API What is the “module” package.json field for? Node.JS (New) Package.json Exports Field","link":"/2023/04/22/package.json-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7%E8%AF%A6%E8%A7%A3/"},{"title":"使用 JavaScript 实现抽象相等比较（&#x3D;&#x3D;）","text":"抽象相等比较（Abstract Equality Comparison）即 == 操作符，又被称作宽松相等、非严格相等。 而在抽象相等比较的过程中，为了使 == 两侧的数据可以进行比较，会尽可能将它们转换成相同类型，这就是的隐式类型转换。 问题先来看看 == 那些令人困惑的例子： 123456789101112131415161718console.log([] == ![]) // trueconsole.log([] == []) // falseconsole.log(0 == '0') // trueconsole.log(0 == []) // trueconsole.log('0' == []) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(null == false) // falseconsole.log(undefined == false) // falseconsole.log(null == undefined) // trueconst a = { toString() { return '0' } }const b = { toString() { return '0' } }console.log(a == 0) // trueconsole.log(b == 0) // trueconsole.log(a == b) // false 让我们根据 ECMA-262 Abstract Equality Comparison 实现一个抽象相等比较吧，以此来了解比较的过程中发生了什么。 实现AbstractEqualityComparison( x, y )抽象相等比较的主体。 规范原文 If Type(x) is the same as Type(y), then ​ a. Return the result of performing Strict Equality Comparison x === y. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y. If Type(x) is BigInt and Type(y) is String, then ​ a. Let n be ! StringToBigInt(y). ​ b. If n is NaN, return false. ​ c. Return the result of the comparison x == n. If Type(x) is String and Type(y) is BigInt, return the result of the comparison y == x. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y). If Type(x) is either String, Number, BigInt, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y). If Type(x) is Object and Type(y) is either String, Number, BigInt, or Symbol, return the result of the comparison ToPrimitive(x) == y. If Type(x) is BigInt and Type(y) is Number, or if Type(x) is Number and Type(y) is BigInt, then ​ a. If x or y are any of NaN, +∞, or -∞, return false. ​ b. If the mathematical value of x is equal to the mathematical value of y, return true; otherwise return false. Return false. 注： x ==! ToNumber(x) 中的 !的意义我不清楚，但早期的规范里是没有!的，且忽略后逻辑是通顺的，后续都将按忽略处理。 译文 当 Type(x) 和 Type(y) 相同时，则 ​ a. 返回 x === y。 当 x 是 null 并且 y 是 undefined 时 true 。 当 x 是 undefined 并且 y 是 null 时 true 。 当 Type(x) 是 Number 并且 Type(y) 是 String 时，返回 x == ToNumber(y) 。 当 Type(x) 是 String 并且 Type(y) 是 Number 时，返回 ToNumber(x) == y 。 当 Type(x) 是 BigInt 并且 Type(y) 是 String 时，则 ​ a. 令 n = StringToBigInt(y) 。 ​ b. 当 n 是 NaN 时，返回 false 。 ​ c. 返回 x == n 。 当 Type(x) 是 String 并且 Type(y) 是 BigInt 时，返回 y == x 。 当 Type(x) 是 Boolean 时，返回 ToNumber(x) == y 。 当 Type(y) 是 Boolean 时，返回 x == ToNumbery) 。 当 Type(x) 是 String, Number, BigInt 或 Symbol 并且 Type(y) 是 Object 时，返回 x == ToPrimitive(y) 。 当 Type(x) 是 Object 并且 Type(y) 是 String, Number, BigInt 或 Symbol 时，返回 ToPrimitive(x) == y 。 当 Type(x) 是 BigInt 并且 Type(y) 是 Number 时，或者 当 Type(y) 是 Number 并且 Type(y) 是 BigInt 时，则 ​ a. 当 x 或 y 是 NaN, +∞, or -∞ 时，返回 false 。 ​ b. 当 x 的数值等于 y 的数值时，返回 true ，反之 false。 返回 false 。 代码最费解的想必就是 ToPrimitive 了，我们可以先不管它，先完成主体。 Type, ToNumber, ToPrimitive 等将会在后续再进行说明。 Number 和 BigInt 的数值比较，可以通过 toString(2) 将它们转成二进制字符串，再进行比较。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function AbstractEqualityComparison(x, y) { /* 1 */ if (Type(x) === Type(y)) { /* a */ return x === y } /* 2 */ if (x === null &amp;&amp; y === undefined) return true /* 3 */ if (x === undefined &amp;&amp; y === null) return true /* 4 */ if (Type(x) === 'number' &amp;&amp; Type(y) === 'string') { return AbstractEqualityComparison(x, ToNumber(y)) } /* 5 */ if (Type(x) === 'string' &amp;&amp; Type(y) === 'number') { return AbstractEqualityComparison(ToNumber(x), y) } /* 6 */ if (Type(x) === 'bigint' &amp;&amp; Type(y) === 'string') { /* a */ const n = StringToBigInt(y) /* b */ if (Number.isNaN(n)) return false /* c */ return AbstractEqualityComparison(x, n) } /* 7 */ if (Type(x) === 'string' &amp;&amp; Type(y) === 'bigint') { return AbstractEqualityComparison(y, x) } /* 8 */ if (Type(x) === 'boolean') { return AbstractEqualityComparison(ToNumber(x), y) } /* 9 */ if (Type(y) === 'boolean') { return AbstractEqualityComparison(x, ToNumber(y)) } /* 10 */ if ( ['string', 'number', 'bigint', 'symbol'].includes(Type(x)) &amp;&amp; Type(y) === 'object' ) { return AbstractEqualityComparison(x, ToPrimitive(y)) } /* 11 */ if ( Type(x) === 'object' &amp;&amp; ['string', 'number', 'bigint', 'symbol'].includes(Type(y)) ) { return AbstractEqualityComparison(ToPrimitive(x), y) } /* 12 */ if ( (Type(x) === 'bigint' &amp;&amp; Type(y) === 'number') || (Type(x) === 'number' &amp;&amp; Type(y) === 'bigint') ) { /* a */ if ([x, y].some(v =&gt; [NaN, Infinity, -Infinity].includes(v))) { return false } /* b */ return x.toString(2) === y.toString(2) } /* 13 */ return false} 注：在 12.a 中的 includes 不可使用 indexOf 代替，[NaN].indexOf(NaN) 始终返回 -1。 Type( argument )Type 的作用是获取数据的类型。 规范原文 An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, BigInt, and Object. An ECMAScript language value is a value that is characterized by an ECMAScript language type. 代码typeof 大致和 Type 一样， 但 typeof 会将 null 认为是 object，把函数认为 function， 单独对这两种类型做调整即可。 123456function Type(argument) { const type = typeof argument if (argument === null) return 'null' if (type === 'function') return 'object' return type} ToNumber( argument )ToNumber 的作用是将其他类型转换成 Number 类型。 规范原文 The abstract operation ToNumber converts argument to a value of type Number according to Table 11: Table 11: ToNumber Conversions Argument Type Result Undefined Return NaN. Null Return +0. Boolean If argument is true, return 1. If argument is false, return +0. Number Return argument (no conversion). String See grammar and conversion algorithm below. Symbol Throw a TypeError exception. BigInt Throw a TypeError exception. Object Apply the following steps:Let primValue be ? ToPrimitive(argument, hint Number).Return ? ToNumber(primValue). 译文 ToNumber 根据表 11将 argument 转换成 Number 类型的值： 表 11: ToNumber 转换 Argument 类型 结果 Undefined 返回 NaN. Null 返回 +0。 Boolean 当 argument 是 true 时，返回 1 。当 argument 是 false 时，返回 +0 。 Number 返回 argument （不进行转换）。 String 见下方语法和转换算法。 Symbol 抛出 TypeError 。 BigInt 抛出 TypeError 。 Object 应用以下步骤：1. 令 primValue = ToPrimitive(argument, hint Number)。2. 返回 ToNumber(primValue) 。 代码ToNumber与Number 几乎一致，只不过对于BigInt，ToNumber会直接抛出类型错误。 123456function ToNumber(argument) { if (Type(argument) === 'bigint') { throw new TypeError('Cannot convert bigint to number value') } return Number(argument)} StringToBigInt( argument )StringToBigInt 的作用是将 String 转成 BigInt。 代码BigInt 中 String 的解析器想必使用的就是 StringToBigInt。 在 BigInt 中当 StringToBigInt 返回值如果是 NaN 则会直接抛出错误。 借用 BigInt 实现 StringToBigInt 则就是捕获错误，返回 NaN 。 1234567891011function StringToBigInt(argument) { if (Type(argument) !== 'string') { throw new TypeError('Only accept string') } try { return BigInt(argument) } catch (e) { return NaN }} ToPrimitive( input [, PreferredType ] )ToPrimitive 的作用是将输入的值转成值类型（除了 Object 以外的基础类型）。 规范原文 Assert: input is an ECMAScript language value. If Type(input) is Object, then ​ a. If PreferredType is not present, let hint be “default”. ​ b. Else if PreferredType is hint String, let hint be “string”. ​ c. Else, ​ i. Assert: PreferredType is hint Number. ​ ii. Let hint be “number”. ​ d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive). ​ e. If exoticToPrim is not undefined, then ​ i. Let result be ? Call(exoticToPrim, input, « hint »). ​ ii. If Type(result) is not Object, return result. ​ iii. Throw a TypeError exception. ​ f. If hint is “default”, set hint to “number”. ​ g. Return ? OrdinaryToPrimitive(input, hint). Return input. 译文 断言： input 是一个 ECMAScript 语言的值. 当 Type(input) 是 Object 时，则 ​ a. 当 PreferredType 不存在时，令 hint = “default” 。 ​ b. 否则当 PreferredType 是 String 时，令 hint = “string” 。 ​ c. 否则， ​ i. 断言： PreferredType 是 Number 。 ​ ii. 令 hint = “number” 。 ​ d. 令 exoticToPrim = GetMethod(input, @@toPrimitive) 。 ​ e. 当 exoticToPrim 不是 undefined 时，则 ​ i. 令 result = Call(exoticToPrim, input, « hint ») 。 ​ ii. 当 Type(result) 不是 Object 时，返回 result 。 ​ iii. 抛出 TypeError 。 ​ f. 当 hint 是 “default” 时，令 hint = “number” 。 ​ g. 返回 OrdinaryToPrimitive(input, hint) 。 返回 input 。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function ToPrimitive(input, PreferredType) { /* 1 不需要实现 */ /* 2 */ if (Type(input) === 'object') { let hint /* a */ if (PreferredType === undefined) { hint = 'default' } /* b */ else if (PreferredType === 'string') { hint = 'string' } /* c */ else { /* i */ if (PreferredType !== 'number') { throw new TypeError('preferred type must be \"string\" or \"number\"') } /* ii */ hint = 'number' } /* d */ const exoticToPrim = GetMethod(input, Symbol.toPrimitive) /* e */ if (exoticToPrim !== undefined) { /* i */ const result = exoticToPrim.call(input, hint) /* i */ if (Type(result) !== 'object') return result /* i */ throw new TypeError('Cannot convert object to primitive value') } /* f */ if (hint === 'default') hint = 'number' /* g */ return OrdinaryToPrimitive(input, hint) } /* 3 */ return input} OrdinaryToPrimitive( o, hint )OrdinaryToPrimitive 是将 Object 转成值类型。 参数 hint 控制优先使用 toString 还是 valueOf。 规范原文 Assert: Type(O) is Object. Assert: Type(hint) is String and its value is either “string” or “number”. If hint is “string”, then ​ a. Let methodNames be « “toString”, “valueOf” ». Else, ​ a. Let methodNames be « “valueOf”, “toString” ». For each name in methodNames in List order, do ​ a. Let method be ? Get(O, name). ​ b. If IsCallable(method) is true, then ​ i. Let result be ? Call(method, O). ​ ii. If Type(result) is not Object, return result. Throw a TypeError exception. 译文 断言： Type(O) 是 Object 。 断言： Type(hint) 是 String 并且 hint 的值 是 “string” 或 “number” 。 当 hint 是 “string” 时，则 ​ a. 令 methodNames = « “toString”, “valueOf” »。 否则， ​ a. 令 methodNames = « “valueOf”, “toString” »。 遍历 methodNames ， 执行 ​ a. 令 method = Get(O, name) 。 ​ b. 当 IsCallable(method) 是 true 时，则 ​ i. 令 result = Call(method, O) 。 ​ ii. 当 Type(result) 不是 Object 时，返回 result 。 抛出 TypeError 。 代码12345678910111213141516171819202122232425262728293031323334353637383940function OrdinaryToPrimitive(o, hint) { /* 1 */ if (Type(o) !== 'object') throw new TypeError('Only accept Object') /* 2 */ if (Type(hint) !== 'string' || !['string', 'number'].includes(hint)) { throw new TypeError('Hint value must be \"string\" or \"number\"') } let methodNames /* 3 */ if (hint === 'string') { /* a */ methodNames = ['toString', 'valueOf'] } /* 4 */ else { /* a */ methodNames = ['valueOf', 'toString'] } /* 5 */ for (const name of methodNames) { /* a */ const method = Get(o, name) /* b */ if (IsCallable(method)) { /* i */ const result = method.call(o) /* ii */ if (Type(result) !== 'object') return result } } /* 6 */ throw new TypeError('Cannot convert object to primitive value')} 其他123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function GetMethod(v, p) { if (!isPropertyKey(p)) { throw new TypeError('Not valid property key') } const func = GetV(v, p) if (func === undefined || func === null) return undefined if (!IsCallable(func)) { throw new TypeError('Not callable') } return func}function isPropertyKey(argument) { if (Type(argument) === 'string') return true if (Type(argument) === 'symbol') return true return false}function Get(o, p) { if (Type(o) !== 'object') { throw new TypeError('Only accept object') } if (!isPropertyKey(p)) { throw new TypeError('Not valid property key') } return o[p]}function GetV(v, p) { if (!isPropertyKey(p)) { throw new TypeError('Not valid property key') } const o = ToObject(v) return o[p]}function IsCallable(argument) { if (Type(argument) !== 'object') return false if (!!argument.call) return true return false}function ToObject(argument) { switch (Type(argument)) { case 'boolean': return new Boolean(argument) case 'number': return new Number(argument) case 'string': return new String(argument) case 'symbol': case 'bigint': case 'object': return argument default: throw new TypeError( `Cannot convert ${Type(argument)} to object value` ) }} 测试123456789101112function test(x, y) { const a = x == y const b = AbstractEqualityComparison(x, y) const sign = a === b ? [ '%cSuccess', 'background: green; color: white;' ] : [ '%cFailure', 'background: red; color: white;' ] console.log(...sign, `[${a}]`, x, y)} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const testData1 = [ undefined, null, true, false, '123', Symbol('123'), 123, 123n, [], { valueOf() { return 123 } }, { toString() { return 123 } }]const testData2 = [ undefined, null, true, false, '123', Symbol('123'), 123, 123n, [], { valueOf() { return 123 } }, { toString() { return 123 } }]testData1.forEach((a) =&gt; { testData2.forEach((b) =&gt; { test(a, b) })}) 结语在实际开发中，是要尽可能避免使用 == 操作符，有人可能觉得这篇文章没有意义。其实我想传达的是一种学习方法，可以通过相同的方式学习 JavaScript 的其他内容。 最后，上面实现的 AbstractEqualityComparison 还是有用处的，我在上面代码的基础上写了个 抽象相等比较过程展示 ，能更清楚地看到比较的过程。不妨输入文章开头的问题，看看比较的过程吧。","link":"/2020/08/31/%E4%BD%BF%E7%94%A8-JavaScript-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%EF%BC%88-%EF%BC%89/"},{"title":"如何创建有序对象？","text":"问题 在不把对象改成数组的情况下，给对象添加新的属性，怎么保证这个属性在遍历的时候是最后一个？ 解答以前 JavaScript 中对象的键名是无序的，后来在 ES2015 之后规定了键名的顺序。 键名数组分为三个部分： 可作为数组索引的键名（如 0, 1, 2），升序排列。 字符串索引，按创建顺序排列。 Symbol 索引，按创建顺序排列。 如果只使用第二类字符串索引，那么默认的顺序就满足需求了。而如果要加上第一类索引，那就需要自己维护键名的数组了，在新增和删除键名时对数组进行操作。 这个场景 Proxy 就再合适不过了。下面的例子是按键名创建顺序排序的对象，如有其他排列需求只需对 ownKeys 做文章即可。 测试用例1234567891011121314151617181920212223242526const obj = proxy({ b: 1, d: 1 })obj.c = 1obj.a = 1delete obj.dObject.defineProperties(obj, { y: { value: 1, enumerable: false, configurable: false, }, x: { value: 1, enumerable: true, configurable: false, },})obj[Symbol(2)] = 1obj[Symbol(1)] = 1console.log(Object.keys(obj))console.log(Object.getOwnPropertyNames(obj))console.log(Object.getOwnPropertySymbols(obj))// b, c, a, x// b, c, a, y, x// Symbol(2), Symbol(1) 代码12345678910111213141516171819202122232425262728293031323334353637function proxy(target) { const keys = Reflect.ownKeys(target) /* 添加 key */ function pushKey(key) { const index = keys.indexOf(key) if (!~index) keys.push(key) } /* 删除 key */ function deleteKey(key) { const index = keys.indexOf(key) if (~index) keys.splice(index, 1) } return new Proxy(target, { defineProperty(target, key, descriptor) { const result = Reflect.defineProperty(target, key, descriptor) /* 定义属性成功 则添加 key*/ if (result) pushKey(key) return result }, deleteProperty(target, key) { const result = Reflect.deleteProperty(target, key) /* 删除属性成功 则删除 key */ if (result) deleteKey(key) return result }, ownKeys() { return [].concat(keys) }, })} defineProperty: 在目标上无论新增还是修改键名/键值，都会触发。 deleteProperty: 在目标上移除键名时，会触发。 ownKeys: 获取键名列表时，返回 keys。 要点说明defineProperty / set handler.set 无法拦截 Object.defineProperty 与 Object.defineProperties。 handler.set 会拦截以代理目标为原型的对象的 set 操作。 故选择了 hanlder.defineProperty。 ownKeys该拦截器可以拦截以下操作： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() Reflect.ownKeys() 所以我们的 keys 应为上述四者的集合， Object.keys() 是 Object.OwnPropertyNames() 的子集， Reflect.ownKeys() 等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。 故在初始化时，应用 Reflect.ownKeys() 创建初始的 keys。 另外该拦截器还存在约束，使用前请务必了解一下： handler.ownKeys 的约束 | MDN。","link":"/2020/06/23/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%9C%89%E5%BA%8F%E5%AF%B9%E8%B1%A1/"},{"title":"将 JSON.stringify 改造成 JS.stringify","text":"JSON.stringify 用来将 JS 变量序列化成 JSON 字符串。一般情况下普通使用是没什么问题了，但需求一旦超过了 JSON 的标准就会存在问题了。比如上篇文章中涉及到的，需要序列化任意 JS 变量用于展示。 下面将会解决 undefined, Function, NaN, Infinity, Symbol, BigInt 的序列化，以及对于循环引用的对象的处理。一步一步将 JSON.stringify 改造成 JS.stringify。推荐直接拉到底部看完整代码，看不懂再回头看思路、说明。 默认情况下 JSON.stringify 会： 忽略 undefined, Function, Symbol。 将 NaN, Infinity, -Infinity 转换成 null 遇到BigInt 会抛出错误。 现在的需求，希望它们会被处理成： undefiend: undefiend Function: &lt;Function&gt; Symbol(123): Symbol(123) NaN: NaN Infinity: Infinity -Infinity: -Infinity BigInt(123): 123n 创建一个测试用例123456789const obj = { undefined: undefined, Function: () =&gt; {}, Symbol: Symbol(123), NaN: NaN, Infinity: Infinity, '-Infinity': -Infinity, BigInt: 123n,} 简单的类型处理可能很多人不知道 JSON.stringify 还有两个可选参数，增加类型处理将会使用第二个 replacer 参数。replacer 详细信息见 JSON.stringify() - MDN。（replacer 有两种重载，后续将只考虑 replacer 为函数的情况） 接着将给 replacer 传入一个函数，来处理变量。replacer 会在进行序列化之前执行，replacer 的返回值会当作序列化的参数。 下面就直接开始实现。 串连 replacers1234567891011121314151617181920/* 待会儿要实现的 replacer */function jsReplacer(key, value) { return value}/* 串连 replacers */function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { return JSON.stringify(value, serializer(replacer, jsReplacer), space)}jsStringify(obj) 通过 serializer 将用户传入的 replacer 和 jsReplacer 进行串连。相当于 123function newReplacer(key, value) { return jsReplacer(key, replacer(key, value)) } 另外JSON.stringify 中 replacer 的 this 会指向 value 的父对象，所以这里需要通过 call 为串连的函数绑定 this。 jsReplacer1234567891011121314151617181920function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return 'undefined' case 'function': return '&lt;Function&gt;' case 'number': if (Number.isNaN(value)) return 'NaN' if (value === Infinity) return 'Infinity' if (value === -Infinity) return '-Infinity' return value case 'symbol': return value.toString() case 'bigint': return `${value}n` default: // 其他类型 不进行处理 直接进行序列化 return value }} 我们需要将不支持的类型，在 jsReplacer 中转换成可以被支持的类型，再交还给 JSON.stringify 进行序列化。一般就是处理成字符串。 合并上面的代码，运行测试用例将会得到： 123456789{ \"undefined\": \"undefined\", \"Function\": \"&lt;Function&gt;\", \"Symbol\": \"Symbol(123)\", \"NaN\": \"NaN\", \"Infinity\": \"Infinity\", \"-Infinity\": \"-Infinity\", \"BigInt\": \"123n\"} 都成功被处理了。但是都处理成字符串，那就会和字符串混淆，无法进行区分。 接着让我们去掉多余的双引号。 移除多余的双引号单单使用 replacer 中我们是无力去掉多余的双引号了，不过我们可以对序列化之后的字符串再加工。 JSON.stringify 返回给我们的是一个字符串，我们需要在这个字符串中找到我们的猎物。为了能够区分我们的猎物和普通猎物，在放生之前给我们的猎物做上标记。 标记123const SIGN = Date.now()const LEFT_MARK = `__${SIGN}`const RIGHT_MARK = `${SIGN}__` 先创建两个标记用来包裹猎物。LEFT_MARK 和 RIGHT_MARK 可以是任意字符串，你只要让它们足够特殊就可以了。这里加入了 Date.now() 做为签名。 123function mark(text) { return `${LEFT_MARK}${text}${RIGHT_MARK}`} 写一个 mark 函数，为猎物做标记，标记方式就是在左右两侧分别加上 LEFT_MARK 与 RIGHT_MARK。 12345678910111213141516171819function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return mark('undefined') case 'function': return mark('&lt;Function&gt;') case 'number': if (Number.isNaN(value)) return mark('NaN') if (value === Infinity) return mark('Infinity') if (value === -Infinity) return mark('-Infinity') return value case 'symbol': return mark(value.toString()) case 'bigint': return mark(`${value}n`) default: return value }} 在 jsReplacer 中使用 mark 对猎物进行标记。 识别用正则去匹配标记，从而获得我们的猎物： 1const REGEXP = new RegExp(`${LEFT_MARK}(.*?)${RIGHT_MARK}`, 'g') 由于我们在 jsReplacer 中处理完的字符串，交给 JSON.stringify 序列化时会多加上引号，所以我们匹配时还得加上引号。 1const REGEXP = new RegExp(`\"${LEFT_MARK}(.*?)${RIGHT_MARK}\"`, 'g') 替换123function unmark(text) { return text.replace(REGEXP, '$1')} 通过String.prototype.replace 将猎物替换成没有引号的。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const SIGN = Date.now()const LEFT_MARK = `__${SIGN}`const RIGHT_MARK = `${SIGN}__`const REGEXP = new RegExp(`\"${LEFT_MARK}(.*?)${RIGHT_MARK}\"`, 'g')function mark(text) { return `${LEFT_MARK}${text}${RIGHT_MARK}`}function unmark(text) { return text.replace(REGEXP, '$1')}function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return mark('undefined') case 'function': return mark('&lt;Function&gt;') case 'number': if (Number.isNaN(value)) return mark('NaN') if (value === Infinity) return mark('Infinity') if (value === -Infinity) return mark('-Infinity') return value case 'symbol': return mark(value.toString()) case 'bigint': return mark(`${value}n`) default: return value }}function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { const replacers = serializer(replacer, jsReplacer) const reuslt = JSON.stringify(value, replacers, space) return unmark(reuslt)} 此时运行测试用例我们将会得到： 123456789{ \"undefined\": undefined, \"Function\": &lt;Function&gt;, \"Symbol\": Symbol(123), \"NaN\": NaN, \"Infinity\": Infinity, \"-Infinity\": -Infinity, \"BigInt\": 123n} 解决对象循环引用同过上述的代码，已经能应付所有类型了，但是面对循环引用的对象，还是会抛出错误。 创建一个测试用例123456const obj = { parent: {}, child: {},}obj.child.parent = obj.parentobj.parent.child = obj.child 简化成二叉树对象也是一个树，可以用最简单的二叉树来思考。 将问题转换成算法题《验证父子不相等二叉树》。 算法题目给定一个二叉树，判断其是否是一个有效的父子不相等二叉树。 假设一个父子不相等二叉树具有如下特征： 任意节点的值不等于其任意位置的父节点的值。 当前节点的所有子节点的值，不等于当前节点的值。 上述两个特征是一个意思，不同的表达方式 示例 112345输入: 1 / \\ 2 2输出: true 示例 21234567输入: 1 / \\ 2 3&nbsp; / \\&nbsp; 1 4输出: false 题解123456789101112131415161718192021222324/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */function isValidTree(root) { const stack = [] function helper(node) { if (node === null) return true const nodeIndex = stack.indexOf(node.val) if (~nodeIndex) return false stack.push(node.val) const res = helper(node.left) &amp;&amp; helper(node.right) stack.pop() return res } return helper(root)} 一个有效树，它的左子树和右子树独立出来也会是有效树。反过来，我们需要判断一个树是否有效，需要知道它的左子树和右子树是否有效，但左子树是否有效与右子树无关，只和父树以及自身的子树有关。因此应该使用深度优先搜索的方法进行遍历。 我们要判断最底层的节点有效性，需要收集它所有的父节点。因此我们需要创建一个栈储存父节点（的值），访问时将当前节点推入栈，当前节点的子节点访问结束之后出栈。 而 JSON.stringify 的 replacer 本身就是深度优先搜索，所以直接通过 replacer 就可以解决循环引用的问题。 模拟 JSON.stringify 内部逻辑但 replacer 和上面的题解有点不同，replacer 中无法知道子节点，只能知道当前节点的父节点（通过 this）。因此我们需要对上面的算法进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function isValidTree(root) { const stack = [] let result = true function helper(node) { if (node === null) return null // this = node 的父节点 // this 是已经经过验证的父节点 或是 根节点 const thisIndex = stack.indexOf(this.val) if (~thisIndex) { // 若 stack 中已存在 this.val // 则表示此次验证的是 this 的右子树 // 那么将移除 this 之后关于左子树的信息 stack.splice(thisIndex + 1) } else { // 若 stack 中不存在 this.val // 则表示此次验证的是 this 的左子树 stack.push(this.val) } // 当前 stack 里存在的是 node 所有父节点的信息 const nodeIndex = stack.indexOf(node.val) if (~nodeIndex) { // 若 stack 中已存在 node.val // 则表示该树不是父子不相等树 result = false // 返回 null，阻止对当前节点的子节点进行搜索 return null } return node } /* 模拟 JSON.stringify 内部遍历 */ // helper 的返回值会作为下次 serch 的节点 // 无法中断操作，只能通过 helper 返回 null 来阻止子节点的搜索 function search(node) { if (node === null) return const left = helper.call(node, node.left) search(left) const right = helper.call(node, node.right) search(right) } search(root) return result} 转换成 replacer1234567891011121314151617181920212223242526272829303132function createCircularReplacer() { const stack = [] return function (key, value) { const thisIndex = stack.indexOf(this) if (~thisIndex) { stack.splice(thisIndex + 1) } else { stack.push(this) } const valueIndex = stack.indexOf(value) if (~valueIndex) return '&lt;Circular&gt;' return value }}function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { const replacers = serializer(replacer, createCircularReplacer()) const result = JSON.stringify(value, replacers, space) return result} 通过闭包将 circularReplacer 的逻辑提到了外面，createCircularReplacer 的返回值相当于之前的 helper。其他基本和上面一一对应，对照着看很容易理解了。 增加路径记录上述返回 &lt;Circular&gt; 只能知道构成了循环引用，但无法得知是从哪儿到哪儿构成循环。 只需要同 stack 相似的方式再增加一个 keys 即可。 1234567891011121314151617181920212223242526272829303132333435363738function createCircularReplacer() { const stack = [] const keys = [] function circulerText(key, value) { const valueIndex = stack.indexOf(value) // 获取与 value 相同的父节点位置 const path = keys.slice(0, valueIndex + 1) // 获取到父节点的完整路径 return `&lt;Circular ${path.join('.')}&gt;` } return function (key, value) { if (stack.length === 0) { // 当 stack 为空时，则表示当前的 value 是根节点 // 可跳过后续处理 // 并且我们并不需要根节点的父节点 stack.push(value) keys.push('~') // 用 ~ 代表根节点的 key return value } const thisIndex = stack.indexOf(this) if (~thisIndex) { stack.splice(thisIndex + 1) keys.splice(thisIndex + 1) } else { stack.push(this) } // 当 value 作为父节点时，无法得到 value 的 key // 所以要在还能知道 key 时将 key 加入到 keys 中 // 所以 keys 表示所有父节点的 key 及自身节点的 key keys.push(key) const valueIndex = stack.indexOf(value) if (~valueIndex) return circulerText(key, value) return value }} 将代码合并后运行测试用例： 123456789101112{ \"parent\": { \"child\": { \"parent\": \"&lt;Circular ~.child&gt;\" } }, \"child\": { \"parent\": { \"child\": \"&lt;Circular ~.parent&gt;\" } }} 基本符合预期了， 然后通过之前说的移除多余的双引号相同的方式进行处理， 我觉得完美了。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const SIGN = Date.now()const LEFT_MARK = `__${SIGN}`const RIGHT_MARK = `${SIGN}__`const REGEXP = new RegExp(`\"${LEFT_MARK}(.*?)${RIGHT_MARK}\"`, 'g')function mark(text) { return `${LEFT_MARK}${text}${RIGHT_MARK}`}function unmark(text) { return text.replace(REGEXP, '$1')}function jsReplacer(key, value) { switch (typeof value) { case 'undefined': return mark('undefined') case 'function': return mark('&lt;Function&gt;') case 'number': if (Number.isNaN(value)) return mark('NaN') if (value === Infinity) return mark('Infinity') if (value === -Infinity) return mark('-Infinity') return value case 'symbol': return mark(value.toString()) case 'bigint': return mark(`${value}n`) default: return value }}function createCircularReplacer() { const stack = [] const keys = [] function circulerText(key, value) { const valueIndex = stack.indexOf(value) const path = keys.slice(0, valueIndex + 1) return mark(`&lt;Circular ${path.join('.')}&gt;`) } return function (key, value) { if (stack.length === 0) { stack.push(value) keys.push('~') return value } const thisIndex = stack.indexOf(this) if (~thisIndex) { stack.splice(thisIndex + 1) keys.splice(thisIndex + 1) } else { stack.push(this) } keys.push(key) const valueIndex = stack.indexOf(value) if (~valueIndex) return circulerText(key, value) return value }}function serializer(...replacers) { const _replacers = replacers.filter((replacer) =&gt; !!replacer) return function (key, value) { return _replacers.reduce((value, replacer) =&gt; { return replacer.call(this, key, value) }, value) }}function jsStringify(value, replacer, space) { const replacers = serializer(replacer, createCircularReplacer(), jsReplacer) const reuslt = JSON.stringify(value, replacers, space) return unmark(reuslt)}","link":"/2021/03/08/%E5%B0%86-JSON-stringify-%E6%94%B9%E9%80%A0%E6%88%90-JS-stringify/"},{"title":"微信小程序 WebView First 开发方案实践","text":"WebView First，是指优先使用 WebView 进行开发，在 WebView 无法满足需求时，再使用原生（微信小程序原生，后续提到原生皆为此意）实现。 前言首先声明立场，我是一个微信小程序黑。作为一个 Web 开发者，内心是抵制小程序的，但奈何生活所迫，该写还是得写。好在还有一条开发的是 Web，但入口是小程序的道路可以走。 尽管在小程序中 WebView 的应用非常普遍，但还是以原生为主的方式进行开发。缺乏以 WebView 为主的案例。 本文是我的 WebView First 实践的记录，希望能给想尝试 WebView First 的各位，提供帮助和底气。 介绍主要原则以 WebView 为主构建小程序，优先通过 JS-SDK 调用微信能力（同公众号），其次再考虑跳转到原生页面调小程序的接口。 尽可能让用户长时间停留在 WebView ，避免 WebView 与原生页面之间切换。 原生页面与 WebView 之间通过 URL 进行通信。 好处 提升开发体验、提高开发效率 降低小程序审核频率 大部分场景下有更好的性能 更多的 npm 包可以使用 更多的解决方案可以参考 更容易地迁移到其他端 那代价是什么？ WebView 页面首次渲染较慢（首次渲染指重启小程序，并非第一次访问小程序）【可用 Web 白屏/首屏问题的优化方式进行优化】 原生页面与 WebView 页面之间，切换成本高【和产品商量，减少这种场景出现】 页面栈管理受限 使用小程序的能力受限【小部分可用 JS-SDK 代替，其余需要跳转到原生页面实现】 Android 下持久储存（如 localStorage、cookie）不符合预期【详细说明见下文】 无法使用现成且丰富的小程序组件【但你有更多组件库可以选择】 部分组件实现的性能不如小程序提供的原生组件 无法使用自定义导航栏【可以跳转到原生页面实现，但不推荐使用的原因同第2点】 页面切换动画效果不一致（WebView 内切换、WebView 与原生之间切换） 原生视频/直播的小窗口（画中画）在安卓中不能带到 WebView【没有很好的解决方案，避免使用画中画时前往 WebView 吧】 与原生 First 的差异 原生 First 即优先使用原生，部分页面嵌入 WebView。 WebView First 大部分操作在 WebView 中进行，大幅度降低了 WebView 页面与原生页面的切换（切换和通信成本较高） WebView First 结构更为简单，基本不需要考虑小程序 持久储存，原生 First 主要存在小程序，WebView First 存在 WebView。 实践 本文将以 Vue 全家桶作为 Web 侧的技术栈进行说明。 小程序页面结构 为了让左上角的出现返回，我们需要一个入口页面（没有内容的），当入口页面 onShow 时，则 navigateTo 到 WebView 页面。 对于其他原生页，建议是想象成弹窗处理，最后都要退回到 WebView 页面。（务必和产品说好，避免出现 WebView 与原生之间的频繁跳转） 环境区分从微信 7.0.0 开始，可以通过判断 userAgent 中包含 miniProgram 字样来判断小程序 WebView 环境。 1const IS_WEAPP = navigator.userAgent.toLowerCase().includes('miniprogram') 原生与 WebView 的通信虽然小程序提供了 message 事件，允许 WebView 向小程序发送消息，但是由于触发条件相当苛刻，很难满足需求。 再由于需要通信的场景都是 WebView 与原生之间切换，所以采用了通过跳转地址进行传参。 具体实现见下一节。 另外，需要注意地址的长度限制。 路由跳转管理路由跳转大致分为三类： WebView 到 WebView 原生到原生 WebView 到原生 原生到 WebView 对应处理方式： 不需要任何处理 不需要任何处理 使用 JS-SDK 进行跳转，使用 navigateTo 将原生页推入页面栈中 尽可能使用后退的形式退回，根据情况，刷新 WebView 的内容。 3、4两种情况尽可能避免，因为 WebView 初始化略慢，这会大大降低用户体验、增加维护的难度。 然后我这边引入了第三方库 qs 用来对 query 进行解析和字符串化。 WebView 跳转到原生我选择了路由配置和导航守卫进行路由管理。 1234567891011121314151617181920212223242526272829303132333435363738const router = createRouter({ routes: [ { path: '/payment', name: 'Payment' component: { /* ... */ }, // 若没有对应的页面，可设置为 404 页 meta: { weapp: '/pages/payment', // 小程序中对应页面的路径 }, }, /* ...其他路由 */ ], /* ...其他配置项 */})router.beforeEach((to) =&gt; { /* 判断小程序环境 */ if (!IS_WEAPP) return true /* 判断 meta.weapp 是否存在 */ if (!to.meta?.weapp) return true // qs.stringify 将对象拼接成 key=value 形式的字符串 const query = qs.stringify({ // 必要的数据统一添加到 query 中，如 token token: 'token', ...to.query }) const url = `${to.meta.weapp}?${query}` /* 调用 JS-SDK 跳转 */ wx.miniProgram.navigateTo({ url }) return false}) 原生跳转到 WebView在小程序中设置一个全局变量作为 web-view 的地址，当原生的 WebView 页面 onShow 时，更新 web-view 组件的 src 的值。 123456789101112131415161718192021222324252627282930313233343536373839// webview-src.js/* 这个就是全局变量，也可以放到 getApp().globalData 中 */export const state = { src: '', query: {}}export function setSrc(options = {}) { state.query = { is_weapp: 'true', ...options.query, } const _query = qs.stringify(query) // __WEBVIEW_URL__ 是 WebView 的访问地址 state.src = `${__WEBVIEW_URL__}${options.path}?${_query}`}export function navigateBack(options, navigateOptions = {}) { setSrc(options) wx.navigateBack(navigateOptions)}export function navigateTo(options, navigateOptions = {}) { setSrc(options) wx.navigateTo({ ...navigateOptions, url: '/pages/webview/index' // WebView 页面路径 })}export function navigateTo(options, navigateOptions = {}) { setSrc(options) wx.navigateTo({ ...navigateOptions, url: '/pages/webview/index' // WebView 页面路径 })} 1234567891011121314// WebView 页面的 js 文件import * as webview from './webview-src'Page({ data: { src: '' }, onShow() { this.setData({ src: webview.state.src }) }}) 持久储存正常来讲，直接使用 localStorage 或是 cookie 作为持久储存就行了。但是安卓中小程序是多进程，不同进程的 WebView 的持久储存数据是隔离的。当你把小程序的进程关了，再打开时可能会拿到和上一次完全不一样的数据。 那么，我们就需要将 WebView 的持久储存数据存到 WebView 之外。可选的只有存到小程序的 storage 和存到服务器。 存小程序的 storage 中，则必须经过 message 事件。存在两个问题：一、message 事件无法稳定触发；二、取回数据只能通过地址传数据，长度存在限制。故，这个方案被放弃了。 存到服务器，首先需要解决的是区分设备，其次再解决安全性的问题。 区分设备我采用的是由服务器生成设备 ID，存在小程序中，通过地址将设备 ID 传给 WebView。 安全性若设备 ID 泄露了，会被轻松获取到全部的持久储存数据。我们可以提高盗用的门槛，增加了一次性签名，以设备 ID 和时间作为签名数据，通过公私钥的形式创建签名。而签名的创建在小程序内进行（WebView 中也行，但会降低安全性），签名也通过地址传给 WebView。 另外还可以定期更换设备 ID。 上传数据也可以适当增加门槛，比如拉取时同样的签名机制，比如拉取时给与上传数据用的 token（下次拉取时失效），等等。 其他说明由于持久储存数据丢失，仅仅只是在小程序进程被杀的情况。所以只需要在小程序首次启动进入 WebView 的时候需要从服务器拉数据。在路由参数中增加首次访问的标识。 Web 侧拉取数据的处理我用了比较粗暴的方案，在创建 Vue 实例前请求数据，将数据更新到持久储存之后直接刷新页面，同时移除地址参数中的设备 ID 和签名。 如果你的项目中，读取持久储存数据都发生在 Vue 实例创建之后，那么不必通过刷新重新读取数据。 1234567891011121314151617181920212223242526272829303132333435363738394041async function pullStorage() { /* 仅小程序环境且是安卓系统 需要拉取数据 */ if (!(IS_WEAPP &amp;&amp; IS_ANDROID)) return const url = new URL(location.href) const deviceId = url.searchParams.get('device_id') // 设备 ID const deviceSign = url.searchParams.get('device_sign') // 拉取数据用的签名 if (!(deviceId &amp;&amp; deviceSign)) return try { /* 发起请求 */ const fetchUrl = `/pull-storage?id=${deviceId}&amp;sign=${deviceSign}` const data = await fetch(fetchUrl).then((res) =&gt; res.json()) /* storageKeys 是项目中所用到的 storage 的键名 */ /* storage 是 localStorage 的封装 */ /* 将拉取到的数据存到 localStorage 中 */ storageKeys.forEach(key =&gt; { const value = data?.[key] storage.setItem(key, value) }) /* 保存设备 ID，用于上传数据 */ storage.setItem('deviceId', deviceId) } catch (err) { console.error(err) // 请求失败不做处理 } finally { url.searchParams.delete('device_id') url.searchParams.delete('device_sign') location.replace(url.toString()) // 刷新页面 await new Promise(() =&gt; {}) // 阻止渲染，等待页面刷新 }}function init() { const app = createApp(App) /* ... */ app.mount('#app')}pullStorage().finally(init) JS-SDK能用 JS-SDK 解决的，就不要跳到原生页面。 不过要注意并不是所有 JS-SDK 的接口都能在小程序中使用，具体请查询 《web-view | 微信开放文档》。 除了小程序特有的路由相关的接口，其他接口均需要先进行权限验证配置。此处有两个坑。 相关配置JS-SDK 所有的参数和配置，均为公众号，而非小程序。appId 使用公众号的；安全域名配置在公众号下。 wx.config 签名参数 url不同设备、不同版本微信 url 的取值不一致。 iOS 首次访问时的地址 Android + 旧版本微信（推测 8.x 之前，没有明确的版本分界线），当前地址 Android + 新版本微信，两者皆可 另外注意不要带 hash。 总结牺牲了特定场景的用户体验和产品设计自由度，换来开发体验、开发效率以及大部分场景的用户体验。 但是，如果对小程序原生组件或能力依赖比较严重（且不能单独分离出来一个页面），或是有不能接受的代价，不建议尝试该方案。 最后，愿世间没有小程序。","link":"/2022/08/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-WebView-First-%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5/"},{"title":"更适合 Vue3 的持久化数据(localStorage)管理库 Prorage","text":"你是否阅读过《你可能不需要 Vuex》或是《你可能不需要 Pinia》？使用 reactive 创建一个全局变量代替 Vuex 或 Pinia，作为全局状态。个人非常喜欢这么做，但没有与之配套的持久化数据方案，于是就产生了 Prorage。 Prorage 简介项目地址：aweikalee/prorage Prorage = Proxy + Storage。 让 localStorage 使用起来像对象一样自然。 基于 @vue/reactivity 实现的持久化数据管理，与 reactive 有着几乎相同的使用方式。与 @vue/reactivity 一样可以脱离 Vue 单独使用。 提供了插件系统，可以实现大部分定制化的需求。内置了有效期、数据转换的插件。 快速上手PlaygroundStackblitz 安装12npm install @vue/reactivitynpm install prorage 如果你已经安装了 Vue，则不需要再安装 @vue/reactivity。 使用123456789import { createStorage, expiresPlugin } from 'prorage'const storage = createStorage()storage.foo = 'foo'delete foostorage.bar = []storage.bar.push('hello') 特性更丰富的数据类型支持localStorage 只支持字符串，通常会使用 JSON.stringify/JSON.parse 对数据处理。 Prorage 在 JSON.stringify/JSON.parse 基础上，以插件(translatePlugin)的形式提供了更多的类型支持。 基础类型支持情况对比：| 数据类型 | localStorage | JSON.stringify | Prorage with translatePlugin || :-: | :-: | :-: | :-: || undefined | ✔️ | ✔️ | ✔️ || null | ✔️ | ✔️ | ✔️ || String | ❌ | ✔️ | ✔️ || Boolean | ❌ | ✔️ | ✔️ || Number | ❌ | ✔️，但不支持 NaN/Infinity/-Infinity | ✔️ || BigInt | ❌ | ❌ | ✔️ || Symbol | ❌ | ❌ | 可以支持 Symbol.for (需用户配置) | 此外还增加了 Date, RegExp 的支持。如果还不满足，则可以通过 translatePlugin 设置更多的类型支持。 Set/Map 实现成本与收益不匹配，并未支持。而 WeakSet/WeakMap 则因实现没有意义，也未支持。 有效期localStorage 不支持设置数据有效期。 Prorage 的 expiresPlugin 插件则提供了设置有效期的支持。 1234567891011import { createStorage, expiresPlugin, useExpires, getExtra } from 'prorage'const storage = createStorage({ plugins: [expiresPlugin()]})storage.foo = useExpires('bar', { days: 7 })console.log(storage.foo) // 'bar'// 7天后console.log(storage.foo) // undefined 和通常的有效期方案不同的是，Prorage 中存在两种有效期检查，一是在数据被读取时检查，二是设置了定时器定期检查，过期的数据将会被拦截/删除。这使得 Prorage 能更好得配合前端框架，及时更新视图。 定制化Prorage 提供了较大的定制空间。 1234567const storage = createStorage({ storage: localStorage, stringify: JSON.stringify, parse: JSON.parse, prefix: 'prefix#', plugins: [expiresPlugin()]}) 参数 说明 storage 储存对象 可替换为 sessionStorage 或是其他 StorageLike stringify 转换为 JSON 字符串的方法 parse 解析 JSON 字符串的方法 prefix 储存键名前缀 plugins 插件 Plugin 插件插件可声明一系列 Hook，在特定时机被调用。通过插件，可以实现大部分定制化的需求。 插件的详细说明请看文档。 循环引用可以借助 flatted 之类的 JSON 库来解决循环引用的问题. 12345678910import { stringify, parse, } from 'flatted'import { createStorage } from 'prorage'const storage = createStorage({ stringify, parse,})storage.test = {}storage.test.circular = storage.test 与 Vue 一起使用Prorage 完全可以当做 reactive 对象使用。 123456789import { watch, computed } from 'vue'import { createStorage } from 'prorage'const storage = createStorage()const foo = computed(() =&gt; storage.foo)watch(() =&gt; storage.bar, (value) =&gt; { console.log(`[bar changed]: ${value}`)}) 与 React 一起使用就和 @vue/reactivity 在 React 中使用一样，以下是一种简单的使用示例：Prorage With React - StackBlitz。 写在后面如果你也不爱使用 Vuex/Pinia，不妨试试使用 Prorage 管理持久化数据。 当然如果你的项目使用了 Vuex/Pinia，那还是更建议使用配套的持久化数据插件。 你有什么想法或建议，欢迎交流。","link":"/2023/07/14/%E6%9B%B4%E9%80%82%E5%90%88-Vue3-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%BA%93-Prorage/"},{"title":"用Hexo建立Blog时所碰到的各种坑","text":"用Hexo建立Blog非常方便，并且有很多现成的主题可以选择。本文章将会记录使用过程中碰到的一些问题，以及解决方法。基础的使用方法请参考Hexo的文档或网络上其他文章。 如何优雅地插入图片本段内容建立在post_asset_folder为true的前提下进行的。开启post_asset_folder后的目录结构如下： 1234_posts├── 文章.md└── 文章 // 文件夹 └── image.jpg 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} 文章中引用图片，官方Hexo 3.0给出的方案。但是本地编写Markdown，体验会变得很糟糕。 解决方法引入hexo-asset-image。原理是遍历内容里的img标签，给src属性补上permalink。（源码不长 推荐直接阅读源码） 1![](image.jpg) 接着就可以直接使用图片名进行引用，会转化为该文章对应的文件夹中的图片。 1![](文章/image.jpg) 不过为了能让本地Markdown编写的体验，所以得在前面加上文件夹名。 但是这种方法只能改变文章内容里的图片地址，对于文件头部Front-matter的图片地址，是无能为力的。关于Front-matter的图片地址的解决方法，请参考文章封面 Thumbnail。 文章封面-Thumbnail这里采用的文章封面解决方案是基于hexo-theme-icarus主题的thumbnail。在文章头部Front-matter中设置属性thumbnail，值设为图片路径。 和正文的图片一样会遇到路径问题，并且官方的图片引用方法和hexo-asset-image都没法解决。 解决方法找到themes\\icarus\\includes\\helpers\\page.js，对get_thumbnail进行修改。 123456789101112131415161718192021222324252627282930hexo.extend.helper.register('get_thumbnail', function (post) { var config = hexo.config; var url = post.thumbnail || '' if ( url &amp;&amp; config.post_asset_folder &amp;&amp; !/http[s]*.*|\\/\\/.*/.test(url) ) { var link = post.permalink; var beginPos = getPosition(link, '/', 3) + 1; var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var linkArray = link.split('/').filter((s) =&gt; s != ''); var urlArray = url.split('/').filter((s) =&gt; s != ''); if(linkArray[linkArray.length - 1] == urlArray[0]) { urlArray.shift(); } url = '/' + link + urlArray.join('/'); } else if (!url) { var imgPattern = /\\&lt;img\\s.*?\\s?src\\s*=\\s*['|\"]?([^\\s'\"]+).*?\\&gt;/ig; var result = imgPattern.exec(post.content); if (result &amp;&amp; result.length &gt; 1) { url = result[1]; } else { url = this.url_for('images/thumbnail.svg'); } } return url}); 如果需要补充路径，则在get_thumbnail中进行补充。 文章锚点文章开启TOC，可以，通过锚点进行文章定位。但是定位时只能定位到窗口的最顶部。当我将navbar固定到顶部后，则定位的内容会被遮住。 解决方法打开themes\\icarus\\source\\js\\main.js，在底部添加代码： 12345678910window.addEventListener('hashchange', function() { var target = $(decodeURI(location.hash)); var htmlFontSize = parseInt($('html').css('font-size')) if(target.length == 1){ var top = target.offset().top - htmlFontSize * 5; if(top &gt; 0){ $('html,body').animate({ scrollTop: top }, 0); } }}); 通过监听hash变化，进行定位修正。其中htmlFontSize * 5 = navbar的高度（4rem）+ 1rem间距。 除此外还有只使用css的解决方法，以及创建隐藏的锚点进行修正。但都需要对Markdown的样式或内容进行修改。 部署缺失README.mdsource文件夹中所有.md文件将会被渲染为html。 解决方法README.md放置于source文件夹下，_config.yml中设置过滤项。 1skip_render: README.md Github Page的Custom domain被清空在Github上设置好Custom domain，在使用hexo deploy进行更新内容，会清空Custom domain。 解决方法在source文件夹中新建文件，命名为CNAME，文件的内容设为Custom domain的值。","link":"/2019/05/28/%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%E6%97%B6%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/"},{"title":"通过 Nginx 给静态资源加上访问密码","text":"有时候服务器上会放一些不希望公开的静态资源，那么我们可以通过 Nginx 和 htpasswd 设置访问密码。 修改 Nginx 配置文件12345server { ... auth_basic \"Please input passwod\"; # 文字提示 chrome中不会显示 auth_basic_user_file /usr/local/nginx/conf/passwd; # 认证文件} 安装 htpasswd1apt-get install apache2-utils htpasswd 是 apache2-utils 或 mini-httpd 附带的程序。所以我们安装这两者其中一个就可以获得 htpasswd 了。 创建认证文件1htpasswd -c /usr/local/src/nginx/passwd username username 是设置的用户名根据提示输入两次密码。 重启 Nginx1nginx -s reload 现在访问网站就需要用户名和密码了。","link":"/2019/08/19/%E9%80%9A%E8%BF%87-nginx-%E7%BB%99%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E4%B8%8A%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Proxy","slug":"Proxy","link":"/tags/Proxy/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Safari","slug":"Safari","link":"/tags/Safari/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"有问不一定答","slug":"有问不一定答","link":"/tags/%E6%9C%89%E9%97%AE%E4%B8%8D%E4%B8%80%E5%AE%9A%E7%AD%94/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"WebView","slug":"WebView","link":"/tags/WebView/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"资料整理","slug":"前端/资料整理","link":"/categories/%E5%89%8D%E7%AB%AF/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"name":"微信小程序","slug":"前端/微信小程序","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"开发记录","slug":"前端/开发记录","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"开发记录","slug":"前端/微信小程序/开发记录","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"Nginx","slug":"服务器/Nginx","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"}]}